<html> <head> <title>Scheduling algorithm</title></head><body>In [[computer science]], a '''scheduling algorithm''' is the method by which [[Thread (computer science)|threads]], [[Process (computing)|processes]] or data [[Flow (computer networking)|flows]] are given access to system resources (e.g. processor time, communications bandwidth). This is usually done to [[Load balancing (computing)|load balance]] a system effectively or achieve a target [[quality of service]]. The need for a scheduling algorithm arises from the requirement for most modern systems to perform [[computer multitasking|multitasking]] (execute more than one process at a time) and [[multiplexing]] (transmit multiple flows simultaneously).

==In computing and multitasking==
The algorithm used may be as simple as [[Round-robin scheduling|round-robin]] in which each process is given equal time (for instance 1 ms, usually between 1 ms and 100 ms) in a cycling list. So, process A executes for 1 ms, then process B, then process C, then back to process A.  

More advanced algorithms take into account process priority, or the importance of the process.  This allows some processes to use more time than other processes. The kernel always uses whatever resources it needs to ensure proper functioning of the system, and so can be said to have infinite priority. In [[Symmetric multiprocessing|SMP]](symmetric multiprocessing) systems, [[processor affinity]] is considered to increase overall system performance, even if it may cause a process itself to run more slowly.  This generally improves performance by reducing [[cache thrashing]].

==In computer networks and multiplexing==
In [[packet-switched]] [[computer networks]] and other [[statistical multiplexing]], the notion of a '''scheduling algorithm''' is used as an alternative to [[FIFO (computing)|first-come first-served]] queuing of data packets. 

The simplest best-effort scheduling algorithms are [[round-robin scheduling|round-robin]], [[fair queuing]] (a [[max-min fair]] scheduling algorithm), [[proportionally fair]] scheduling and [[maximum throughput scheduling|maximum throughput]]. If differentiated or guaranteed [[quality of service]] is offered, as opposed to best-effort communication, [[weighted fair queuing]] may be utilized.

In advanced packet radio wireless networks such as [[HSDPA]] (High-Speed Downlink Packet Access ) [[3.5G]] cellular system, '''channel-dependent scheduling''' may be used to take advantage of [[channel state information]]. If the channel conditions are favourable, the [[throughput]] and [[system spectral efficiency]] may  be increased. In even more advanced systems such as [[LTE_Advanced|LTE]], the scheduling is combined by channel-dependent packet-by-packet [[dynamic channel allocation]], or by assigning [[OFDMA]] multi-carriers or other [[frequency-domain equalization]] components to the users that best can utilize them.

==In computer I/O==
Determines the order in which disk I/O requests are pushed to the disk device.

==See also==
* [[Atropos scheduler]]
* [[Completely Fair Scheduler]]
* [[Dynamic priority scheduling]]
* [[Earliest deadline first scheduling]]
* [[Foreground-background]]
* [[I/O scheduling]]
* [[Job Shop Scheduling]]
* [[Least slack time scheduling]]
* [[Lottery scheduling]]
* [[Multilevel feedback queue]]
* [[O(1) scheduler]]
* [[Rate-monotonic scheduling]]
* [[Round-robin scheduling]]
* [[Scheduling (communications)]]
* [[Scheduling (computing)]]

==External links==
* [http://joshaas.net/linux/ Josh Aas' introduction to the Linux 2.6.8.1 CPU scheduler implementation]
* Peter Brucker, Sigrid Knust. Complexity results for scheduling problems [http://www.mathematik.uni-osnabrueck.de/research/OR/class/]
*[http://rtime.felk.cvut.cz/scheduling-toolbox TORSCHE Scheduling Toolbox for Matlab] is a toolbox of scheduling and graph algorithms.

[[Category:Scheduling algorithms|*]]
[[Category:Planning]]

[[es:Algoritmo de planificación]]
[[he:אלגוריתם תזמון]]
[[ja:パケット・スケジューリング]]</body> </html>