<html> <head> <title>Normalization property (abstract rewriting)</title></head><body>{{Unreferenced|date=December 2009}}
In [[mathematical logic]] and [[theoretical computer science]], a [[rewrite system]] has the '''strong normalization property''' (in short: the '''normalization property''') if every term is ''strongly normalizing''; that is, if every sequence of rewrites eventually terminates to a term in [[Normal form (term rewriting)|normal form]]. A rewrite system may also have the '''weak normalization property''', meaning that for every term, there exists at least one particular sequence of rewrites that eventually yields a normal form.

== Lambda calculus ==

=== Untyped lambda calculus ===
The ''pure'' untyped [[lambda calculus]] does not satisfy the strong normalization property, and not even the weak normalization property. Consider the term <math>\lambda x . x x x</math>. It has the following rewrite rule: For any term <math>t</math>,

: <math>(\mathbf{\lambda} x . x x x) t \rightarrow t t t</math>

But consider what happens when we apply <math>\lambda x . x x x</math> to itself:
{|
| <math>(\mathbf{\lambda} x . x x x) (\lambda x . x x x)</math>
| <math> \rightarrow (\mathbf{\lambda} x . x x x) (\lambda x . x x x) (\lambda x . x x x)</math>
|-
|
| <math>  \rightarrow (\mathbf{\lambda} x . x x x) (\lambda x . x x x) (\lambda x . x x x) (\lambda x . x x x)</math>
|-
|
| <math>  \rightarrow (\mathbf{\lambda} x . x x x) (\lambda x . x x x) (\lambda x . x x x) (\lambda x . x x x) (\lambda x . x x x)</math>
|-
|
| <math>\ldots\,</math>
|}

Therefore the term <math>(\lambda x . x x x) (\lambda x . x x x)</math> is not strongly normalizing.

=== Typed lambda calculus ===

Various systems of [[typed lambda calculus]] including the
[[typed lambda calculus|simply typed lambda calculus]], [[Jean-Yves Girard]]'s [[System F]], and [[Thierry Coquand]]'s [[calculus of constructions]] are strongly normalizing.

A lambda calculus system with the '''normalization property''' can be viewed as a programming language with the property that every program [[termination analysis|terminates]]. Although this is a very useful property, it has a drawback: a programming language with the normalization property cannot be [[turing completeness|Turing complete]]. That means that there are computable functions that cannot be defined in the simply typed lambda calculus (and similarly there are computable functions that cannot be computed in the calculus of constructions or System F).  As an example, it is impossible to define a [[self-interpreter]] in any of the calculi cited above.<ref>Conor McBride (May 2003), [http://www.haskell.org/pipermail/haskell-cafe/2003-May/004343.html "on termination"] (posted to the Haskell-Cafe mailing list).</ref>

==See also==
* [[Typed lambda calculus]]
* [[Rewriting]]
* [[Total functional programming]]
* [[Barendregt&ndash;Geuvers&ndash;Klop conjecture]]

{{DEFAULTSORT:Normalization Property (Lambda-Calculus)}}
[[Category:Lambda calculus]]
[[Category:Logic in computer science]]

[[eo:Normaliga propraĵo (lambda-kalkulo)]]
[[zh:规范化性质]]

==References==
{{Reflist}}</body> </html>