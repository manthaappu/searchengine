<html> <head> <title>Pushdown automaton</title></head><body>In [[automata theory]], a '''pushdown automaton''' (PDA) is a [[finite state machine|finite automaton]] that can make use of a [[Stack (data structure)|stack]] containing data.
== Operation ==
[[Image:Pushdown-overview.svg|thumb|340px|a diagram of the pushdown automaton]]
Pushdown automata differ from [[finite state machine]]s in two ways:
# They can use the top of the stack to decide which transition to take. 
# They can manipulate the stack as part of performing a transition.

Pushdown automata choose a transition by indexing a table by input signal, current state, and the symbol at the top of the stack. This means that those three parameters completely determine the transition path that is chosen. Finite state machines just look at the input signal and the current state: they have no stack to work with. Pushdown automata add the stack as a parameter for choice.

Pushdown automata can also manipulate the stack, as part of performing a transition. Finite state machines choose a new state, the result of following the transition. The manipulation can be to push a particular symbol to the top of the stack, or to pop off the top of the stack. The automaton can alternatively ignore the stack, and leave it as it is. The choice of manipulation (or no manipulation) is determined by the transition table.

Put together: Given an input signal, current state, and stack symbol, the automaton can follow a transition to another state, and optionally manipulate (push or pop) the stack.

In general pushdown automata may have several computations on a given input string, some of which may be halting in accepting configurations while others are not. Thus we have a model which is technically known as a "nondeterministic pushdown automaton" (NPDA). Nondeterminism means that there may be more than just one transition available to follow, given an input signal, state, and stack symbol. If in every situation only one transition is available as continuation of the computation, then the result is a [[deterministic pushdown automaton]] (DPDA), a strictly weaker device.  

If we allow a finite automaton access to two stacks instead of just one, we obtain a more powerful device, equivalent in power to a [[Turing machine]]. A [[linear bounded automaton]] is a device which is more powerful than a pushdown automaton but less so than a Turing machine.

Pushdown automata are equivalent to [[context-free grammars]]: for every context-free grammar, there exists a pushdown automaton such that the language generated by the grammar is identical with the language generated by the automaton, which is easy to prove. The reverse is true, though harder to prove: for every pushdown automaton there exists a context-free grammar such that the language generated by the automaton is identical with the language generated by the grammar.

== Formal Definition ==

A PDA is formally defined as a 7-tuple:

<math>M=(Q,\  \Sigma,\  \Gamma,\  \delta, \ q_{0},\ Z, \ F)</math>
where

*<math>\, Q </math> is a finite set of <em>states</em>
*<math>\,\Sigma</math> is a finite set which is called the <em>input alphabet</em>
*<math>\,\Gamma</math> is a finite set which is called the <em>stack alphabet</em>
*<math>\,\delta</math> is a mapping of  <math>Q \times  (\Sigma \cup\{\varepsilon\})  \times \Gamma </math> into <math> Q \times \Gamma^* </math>, the <em>transition relation</em>, where <math>\Gamma^{*}</math> means "a finite (maybe empty) list of element of <math>\Gamma</math>" and <math>\varepsilon</math> denotes the [[empty string]].
*<math>\,q_{0}\in\, Q </math> is the <em>start state</em>
*<math>\ Z\in\,\Gamma</math> is the <em>initial stack symbol</em>
*<math>F\subseteq Q</math> is the set of <em>accepting states</em>

An element <math>(p,a,A,q,\alpha) \in \delta</math> is a transition of <math>M</math>. It has the intended meaning that <math>M</math>, in state <math>p \in Q</math>, with <math>a \in \Sigma \cup\{\varepsilon\}</math> on the input and with <math>A \in \Gamma</math> as topmost stack symbol, may read <math>a</math>, change the state to <math>q</math>, pop <math>A</math>, replacing it by pushing <math>\alpha \in \Gamma^*</math>. The letter <math>\epsilon</math> (epsilon) denotes the [[empty string]] and the <math>(\Sigma \cup\{\varepsilon\})</math> component of the transition relation is used to formalize that the PDA can either read a letter from the input, or proceed leaving the input untouched.
 
In many texts the transition relation is replaced by an (equivalent) formalization, where 

* <math>\,\delta</math> is the <em>transition function</em>, mapping <math>Q \times (\Sigma \cup\{\varepsilon\}) \times \Gamma</math> into finite subsets of <math>Q \times \Gamma^*</math>. 

Here <math>\delta(p,a,A)</math> contains all possible actions in state <math>p</math> with <math>A</math> on the stack, while reading <math>a</math> on the input. One writes <math>(q,\alpha) \in \delta(p,a,A)</math> for the function precisely when <math>(p,a,A,q,\alpha) \in\delta</math> for the relation. Note that <em>finite</em> in this definition is essential.

''' ''Computations'' '''    

[[Image:Pushdown-step.svg|thumb|200px|a step of the pushdown automaton]]
In order to formalize the semantics of the pushdown automaton a description of the current situation is introduced. Any 3-tuple <math>(p,w,\beta) \in Q \times \Sigma^* \times \Gamma^*</math> is called an instantaneous description (ID) of <math>M</math>, which includes the current state, the part of the input tape that has not been read, and the contents of the stack (topmost symbol written first). The transition relation <math>\delta</math> defines the step-relation <math>\vdash_{M}</math> of <math>M</math> on instantaneous descriptions. For instruction <math>(p,a,A,q,\alpha) \in \delta</math> there exists a step <math>(p,ax,A\gamma) \vdash_{M} (q,x,\alpha\gamma)</math>, for every <math>x\in\Sigma^*</math> and every <math>\gamma\in \Gamma^*</math>.

In general pushdown automata are nondeterministic meaning that in a given instantaneous description <math>(p,w,\beta)</math> there may be several possible steps. Any of these steps can be chosen in a computation.
With the above definition in each step always a single symbol (top of the stack) is popped, replacing it with as many symbols as necessary. As a consequence no step is defined when the stack is empty.

Computations of the pushdown automaton are sequences of steps. The computation starts in the initial state <math>q_{0}</math> with the initial stack symbol <math>Z</math> on the stack, and a string <math>w</math> on the input tape, thus with initial description <math>(q_{0},w,Z)</math>. 
There are two modes of accepting. The pushdown automaton either accepts by final state, which means after reading its input the automaton reaches an accepting state (in <math>F</math>), or it accepts by empty stack (<math>\varepsilon</math>), which means after reading its input the automaton empties its stack. The first acceptance mode uses the internal memory (state), the second the external memory (stack).

Formally one defines
# <math>L(M) = \{ w\in\Sigma^* | (q_{0},w,Z) \vdash_M^* (f,\varepsilon,\gamma)</math> with <math>f \in F</math> and <math>\gamma \in \Gamma^* \}</math> (final state)
# <math>N(M) = \{ w\in\Sigma^* | (q_{0},w,Z) \vdash_M^* (q,\varepsilon,\varepsilon)</math> with <math>q \in Q \}</math> (empty stack)

Here <math>\vdash_M^*</math> represents the reflexive and transitive closure of the step relation <math>\vdash_M</math> meaning any number of consecutive steps (zero, one or more).

For each single pushdown automaton these two languages need to have no relation: they may be equal but usually this is not the case. A specification of the automaton should also include the intended mode of acceptance. Taken over all pushdown automata both acceptance conditions define the same family of languages.

'''Theorem.''' For each pushdown automaton <math>M</math> one may construct a pushdown automaton <math>M'</math> such that <math>L(M)=N(M')</math>, and vice versa, for each pushdown automaton <math>M</math> one may construct a pushdown automaton <math>M'</math> such that <math>N(M)=L(M')</math>

== Example ==

The following is the formal description of the PDA which recognizes the language <math>\{0^n1^n \mid n \ge 0 \}</math> by final state:

[[Image:Pda-example.svg|thumb|250px|PDA for <math>\{0^n1^n \mid n \ge 0\}</math> (by final state)]]
<math>M=(Q,\  \Sigma,\  \Gamma,\  \delta, \ p,\ Z, \ F)</math>, where

<math>Q = \{ p,q,r \}</math>

<math>\Sigma = \{0, 1\}</math>

<math>\Gamma = \{A, Z\}</math>

<math>F = \{r\}</math>

<math>\delta</math> consists of the following six instructions:

<math>(p,0,Z,p,AZ)</math>,
<math>(p,0,A,p,AA)</math>,
<math>(p,\epsilon,Z,q,Z)</math>,
<math>(p,\epsilon,A,q,A)</math>,
<math>(q,1,A,q,\epsilon)</math>, and
<math>(q,\epsilon,Z,r,Z)</math>.

In words, in state <math>p</math> for each symbol <math>0</math> read, one <math>A</math> is pushed onto the stack. Pushing symbol <math>A</math> on top of another <math>A</math> is formalized as replacing top <math>A</math> by <math>AA</math>. In state <math>q</math> for each symbol <math>1</math> read one <math>A</math> is popped. At any moment the automaton may move from state <math>p</math> to state <math>q</math>, while it may move from state <math>q</math> to accepting state <math>r</math> only when the stack consists of a single <math>Z</math>.

There seems to be no generally used representation for PDA. Here we have depicted the instruction <math>(p,a,A,q,\alpha)</math> by an edge from state <math>p</math> to state <math>q</math> labelled by  <math>a; A/\alpha</math> (read <math>a</math>; replace <math>A</math> by <math>\alpha</math>).

==Understanding the computation process==

[[Image:Pda-steps.svg|thumb|340px|accepting computation for <math>0011</math>]]
The following illustrates how the above PDA computes on different input strings. The subscript <math>M</math> from the step symbol <math>\vdash</math> is here omitted.

(a)  Input string = 0011. There are various computations, depending on the moment the move from state <math>p</math> to state <math>q</math> is made. Only one of these is accepting.

: (i) <math>(p,0011,Z) \vdash (q,0011,Z) \vdash (r,0011,Z)</math>. The final state is accepting, but the input is not accepted this way as it has not been read.

: (ii) <math>(p,0011,Z) \vdash (p,011,AZ) \vdash (q,011,AZ)</math>. No further steps possible.

: (iii) <math>(p,0011,Z) \vdash (p,011,AZ) \vdash (p,11,AAZ) \vdash (q,11,AAZ)</math> <math> \vdash (q,1,AZ) \vdash (q,\epsilon,Z)</math> <math> \vdash (r,\epsilon,Z)</math>. Accepting computation: ends in accepting state, while complete input has been read.

(b)  Input string = 00111. Again there are various computations. None of these is accepting.

: (i) <math>(p,00111,Z) \vdash (q,00111,Z) \vdash (r,00111,Z)</math>. The final state is accepting, but the input is not accepted this way as it has not been read.

: (ii) <math>(p,00111,Z) \vdash (p,0111,AZ) \vdash (q,0111,AZ)</math>. No further steps possible.

: (iii) <math>(p,00111,Z) \vdash (p,0111,AZ) \vdash (p,111,AAZ) \vdash (q,111,AAZ)</math> <math> \vdash (q,11,AZ) \vdash (q,1,Z)</math> <math> \vdash (r,1,Z)</math>. The final state is accepting, but the input is not accepted this way as it has not been (completely) read.

==PDA and Context-free Languages==

Every context-free grammar can be transformed into an equivalent pushdown automaton. The derivation process of the grammar is simulated in a leftmost way. Where the grammar rewrites a nonterminal, the PDA takes the topmost nonterminal from its stack and replaces it by the right-hand part of a grammatical rule (expand). Where the grammar generates a terminal symbol, the PDA reads a symbol from input when it is the topmost symbol on the stack (match). In a sense the stack of the PDA contains the unprocessed data of the grammar, corresponding to a pre-order traversal of a derivation tree.

Technically, given a context-free grammar, the PDA is constructed as follows.

# <math>(1,\varepsilon,A,1,\alpha)</math> for each rule <math>A\to\alpha</math> (<em>expand</em>)
# <math>(1,a,a,1,\varepsilon)</math> for each terminal symbol <math>a</math> (<em>match</em>)

As a result we obtain a single state pushdown automaton, the state here is <math>1</math>, accepting the context-free language by empty stack. Its initial stack symbol equals the axiom of the context-free grammar.

The converse, finding a grammar for a given PDA, is not that easy. The trick is to code two states of the PDA into the nonterminals of the grammar.

'''Theorem.''' For each pushdown automaton <math>M</math> one may construct a context-free grammar <math>G</math> such that <math>N(M)=L(G)</math>.

==Generalized Pushdown Automaton (GPDA)==

A GPDA is a PDA which writes an entire string of some known length to the stack or removes an entire string from the stack in one step.

A GPDA is formally defined as a 6-tuple: 
:<math>M=(Q,\  \Sigma,\  \Gamma,\  \delta, \ q_{0}, \ F)</math>
where Q, <math>\Sigma\,</math>, <math>\Gamma\,</math>, q<sub>0</sub> and F are defined the same way as a PDA.
:<math>\,\delta</math>: <math>Q \times  \Sigma_{\epsilon}  \times \Gamma^{*} \longrightarrow P( Q \times \Gamma^{*} )</math>
is the transition function. 

Computation rules for a GPDA are the same as a PDA except that the a<sub>i+1</sub>'s and b<sub>i+1</sub>'s are now strings instead of symbols.

GPDA's and PDA's are equivalent in that if a language is recognized by a PDA, it is also recognized by a GPDA and vice versa.

One can formulate an analytic proof for the equivalence of GPDA's and PDA's using the following simulation:

Let <math>\delta</math>(q<sub>1</sub>, w, x<sub>1</sub>x<sub>2</sub>...x<sub>m</sub>) <math>\longrightarrow</math> (q<sub>2</sub>, y<sub>1</sub>y<sub>2</sub>...y<sub>n</sub>) be a transition of the GPDA 

where <math>q_1, q_2 \in Q</math>, <math>w \in\Sigma_{\epsilon}</math>, <math>x_1, x_2,\ldots,x_m\in\Gamma^{*}</math>, <math>m\geq0</math>, <math>y_1, y_2,\ldots,y_n\in\Gamma^{*}</math>, <math>n\geq 0</math>.

Construct the following transitions for the PDA:

::<math>\delta^{'}</math>(q<sub>1</sub>, w, x<sub>1</sub>) <math>\longrightarrow</math> (p<sub>1</sub>, <math>\epsilon</math>)

::<math>\delta^{'}</math>(p<sub>1</sub>, <math>\epsilon</math>, x<sub>2</sub>) <math>\longrightarrow</math> (p<sub>2</sub>, <math>\epsilon</math>)

::::<math>\vdots</math>

::<math>\delta^{'}</math>(p<sub>m-1</sub>, <math>\epsilon</math>, x<sub>m</sub>) <math>\longrightarrow</math> (p<sub>m</sub>, <math>\epsilon</math>)

::<math>\delta^{'}</math>(p<sub>m</sub>, <math>\epsilon</math>, <math>\epsilon</math> ) <math>\longrightarrow</math> (p<sub>m+1</sub>, y<sub>n</sub>)

::<math>\delta^{'}</math>(p<sub>m+1</sub>, <math>\epsilon</math>, <math>\epsilon</math> ) <math>\longrightarrow</math> (p<sub>m+2</sub>, y<sub>n-1</sub>)

::::<math>\vdots</math>

::<math>\delta^{'}</math>(p<sub>m+n-1</sub>, <math>\epsilon</math>, <math>\epsilon</math> ) <math>\longrightarrow</math> (q<sub>2</sub>, y<sub>1</sub>)

==See also==
* [[Stack machine]]
* [[Context-free grammar]]
* [[Finite automaton]]
* [[Nondeterministic finite state machine]]

==References==
{{Refbegin}}
* {{cite book|author = [[Michael Sipser]] | year = 1997 | title = Introduction to the Theory of Computation | publisher = PWS Publishing | isbn = 0-534-94728-X}} Section 2.2: Pushdown Automata, pp.101&ndash;114.
{{Refend}}

==External links==
* [http://planetmath.org/encyclopedia/PushdownAutomaton.html non-deterministic pushdown automaton], on Planet Math.
* [http://www.jflap.org JFLAP], simulator for several types of automata including nondeterministic pushdown automata

{{Formal languages and grammars}}

[[Category:Automata theory]]
[[Category:Computational models]]

[[ar:الأوتومات غير المنتهي ذو المكدس]]
[[bs:Potisni automat]]
[[cs:Zásobníkový automat]]
[[de:Kellerautomat]]
[[es:Autómata con pila]]
[[fr:Automate à pile]]
[[hr:Potisni automat]]
[[it:Automa a pila]]
[[he:אוטומט מחסנית]]
[[mk:Pushdown автомат]]
[[nl:Stapelautomaat]]
[[ja:プッシュダウン・オートマトン]]
[[pl:Automat ze stosem]]
[[pt:Autômato de pilha]]
[[ru:Автомат с магазинной памятью]]
[[sk:Zásobníkový automat]]
[[sr:Потисни аутомат]]
[[sh:Potisni automat]]
[[fi:Pinoautomaatti]]
[[zh:下推自动机]]</body> </html>