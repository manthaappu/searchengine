<html> <head> <title>Natural deduction</title></head><body>In [[logic]] and [[proof theory]], '''natural deduction''' is a kind of [[proof calculus]] in which [[logical reasoning]] is expressed by [[inference rules]] closely related to the "natural" way of reasoning. This contrasts with the [[axiomatic system]]s which instead use [[axiom]]s as much as possible to express the logical laws of [[deductive reasoning]].
== Motivation ==
Natural deduction grew out of a context of dissatisfaction with the axiomatizations of deductive reasoning common to the systems of [[David Hilbert|Hilbert]], [[Gottlob Frege|Frege]], and [[Bertrand Russell|Russell]] (see, e.g., [[Hilbert system]]). Such axiomatizations were most famously used by [[Bertrand Russell|Russell]] and [[Alfred North Whitehead|Whitehead]] in their mathematical treatise ''[[Principia Mathematica]]''. Spurred on by a series of seminars in Poland in 1926 by [[Jan Lukasiewicz|Łukasiewicz]] that advocated a more natural treatment of logic, [[Stanisław Jaśkowski|Jaśkowski]] made the earliest attempts at defining a more natural deduction, first in 1929 using a diagrammatic notation, and later updating his proposal in a sequence of papers in 1934 and 1935. His proposals led to different notations
such as [[Fitch-style calculus]] (or Fitch's diagrams) or [[Patrick Suppes|Suppes]]' method of which e.g. [[John Lemmon|Lemmon]] gave a variant called [[system L (Lemmon)|system L]].

Natural deduction in its modern form was independently proposed by the German mathematician [[Gerhard Gentzen|Gentzen]] in 1935, in a dissertation delivered to the faculty of mathematical sciences of the university of Göttingen. The term ''natural deduction'' (or rather, its German equivalent ''natürliches Schließen'') was coined in that paper:

{{quote|Ich wollte zunächst einmal einen Formalismus aufstellen, der dem wirklichen Schließen möglichst nahe kommt. So ergab sich ein „Kalkül des natürlichen Schließens“.<br/>
(First I wished to construct a formalism that comes as close as possible to actual reasoning. Thus arose a "calculus of natural deduction".)|Gentzen, ''Untersuchungen über das logische Schließen'' (Mathematische Zeitschrift 39, pp.176–210, 1935)}}

Gentzen was motivated by a desire to establish the consistency of number theory, and he found immediate use for his natural deduction calculus. He was nevertheless dissatisfied with the complexity of his proofs, and in 1938 gave a new consistency proof using his [[sequent calculus]]. In a series of seminars in 1961 and 1962 [[Dag Prawitz|Prawitz]] gave a comprehensive summary of natural deduction calculi, and transported much of Gentzen's work with sequent calculi into the natural deduction framework. His 1965 monograph ''Natural deduction: a proof-theoretical study'' was to become a reference work on natural deduction, and included applications for [[modal logic|modal]] and [[second-order logic]].

In natural deduction, a [[proposition]] is deduced from a collection of premises by applying inference rules repeatedly. The system presented in this article is a minor variation of Gentzen's or Prawitz's formulation, but with a closer adherence to [[Per Martin-Löf|Martin-Löf]]'s description of logical judgments and connectives (Martin-Löf, 1996).

==Judgments and propositions==
A ''[[Judgment (mathematical logic)|judgment]]'' is something that is knowable, that is, an object of knowledge. It is ''evident'' if one in fact knows it. Thus "''it is raining''" is a judgment, which is evident for the one who knows that it is actually raining; in this case one may readily find evidence for the judgment by looking outside the window or stepping out of the house. In mathematical logic however, evidence is often not as directly observable, but rather deduced from more basic evident judgments. The process of deduction is what constitutes a ''proof''; in other words, a judgment is evident if one has a proof for it.

The most important judgments in logic are of the form "''A is true''". The letter ''A'' stands for any expression representing a ''proposition''; the truth judgments thus require a more primitive judgment: "''A is a proposition''". Many other judgments have been studied; for example, "''A is false''" (see [[classical logic]]), "''A is true at time t''" (see [[temporal logic]]), "''A is necessarily true''" or "''A is possibly true''" (see [[modal logic]]), "''the program M has type τ''" (see [[programming language]]s and [[type theory]]), "''A is achievable from the available resources''" (see [[linear logic]]), and many others. To start with, we shall concern ourselves with the simplest two judgments "''A is a proposition''" and "''A is true''", abbreviated as "''A'' prop" and "''A'' true" respectively.

The judgment "''A'' prop" defines the structure of valid proofs of ''A'', which in turn defines the structure of propositions. For this reason, the [[inference rule]]s for this judgment are sometimes known as ''formation rules''. To illustrate, if we have two propositions ''A'' and ''B'' (that is, the judgments "''A'' prop" and "''B'' prop" are evident), then we form the compound proposition ''A and B'', written symbolically as "<math>A \wedge B</math>". We can write this in the form of an inference rule:
<div style="margin-left: 2em;">
<math>\frac{A\hbox{ prop} \qquad B\hbox{ prop}}{A \wedge B\hbox{ prop}}\ \wedge_F</math>
</div>
This inference rule is ''schematic'': ''A'' and ''B'' can be instantiated with any expression. The general form of an inference rule is:
<div style="margin-left: 2em;">
<math>\frac{J_1 \qquad J_2 \qquad \cdots \qquad J_n}{J}\ \hbox{name}</math>
</div>
where each <math>J_i</math> is a judgment and the inference rule is named "name". The judgments above the line are known as ''premises'', and those below the line are ''conclusions''. Other common logical propositions are disjunction (<math>A \vee B</math>), negation (<math>\neg A</math>), implication (<math>A \supset B</math>), and the logical constants truth (<math>\top</math>) and falsehood (<math>\bot</math>). Their formation rules are below.
<div style="margin-left: 2em;">
<math>
\frac{A\hbox{ prop} \qquad B\hbox{ prop}}{A \vee B\hbox{ prop}}\ \vee_F
\qquad
\frac{A\hbox{ prop} \qquad B\hbox{ prop}}{A \supset B\hbox{ prop}}\ \supset_F
\qquad
\frac{\hbox{ }}{\top\hbox{ prop}}\ \top_F
\qquad
\frac{\hbox{ }}{\bot\hbox{ prop}}\ \bot_F
</math>
</div>

<div style="margin-left: 2em;">
<math>
\qquad
\frac{A\hbox{ prop}}{\neg A\hbox{ prop}}\ \neg_F
</math>
</div>

==Introduction and elimination==
Now we discuss the "''A'' true" judgment. Inference rules that introduce a logical connective in the conclusion are known as ''introduction rules''. To introduce conjunctions, ''i.e.'', to conclude "''A and B'' true" for propositions ''A'' and ''B'', one requires evidence for "''A'' true" and "''B'' true". As an inference rule:
<div style="margin-left: 2em">
<math>
\frac{A\hbox{ true} \qquad B\hbox{ true}}{A \wedge B\hbox{ true}}\ \wedge_I
</math>
</div>
It must be understood that in such rules the objects are propositions. That is, the above rule is really an abbreviation for:
<div style="margin-left: 2em">
<math>
\frac{A\hbox{ prop} \qquad B\hbox{ prop} \qquad A\hbox{ true} \qquad B\hbox{ true}}{A \wedge B\hbox{ true}}\ \wedge_I
</math>
</div>
This can also be written:
<div style="margin-left: 2em">
<math>
\frac{A \wedge B\hbox{ prop} \qquad A\hbox{ true} \qquad B\hbox{ true}}{A \wedge B\hbox{ true}}\ \wedge_I
</math>
</div>
In this form, the first premise can be satisfied by the <math>\wedge_F</math> formation rule, giving the first two premises of the previous form. In this article we shall elide the "prop" judgments where they are understood. In the nullary case, one can derive truth from no premises.
<div style="margin-left: 2em">
<math>
\frac{\ }{\top\hbox{ true}}\ \top_I
</math>
</div>
If the truth of a proposition can be established in more than one way, the corresponding connective has multiple introduction rules.
<div style="margin-left: 2em">
<math>
\frac{A\hbox{ true}}{A \vee B\hbox{ true}}\ \vee_{I1}
\qquad
\frac{B\hbox{ true}}{A \vee B\hbox{ true}}\ \vee_{I2}
</math>
</div>
Note that in the nullary case, ''i.e.'', for falsehood, there are ''no'' introduction rules. Thus one can never infer falsehood from simpler judgments.

Dual to introduction rules are ''elimination rules'' to describe how to de-construct information about a compound proposition into information about its constituents. Thus, from "''A ∧ B'' true", we can conclude "''A'' true" and "''B'' true":
<div style="margin-left: 2em">
<math>
\frac{A \wedge B\hbox{ true}}{A\hbox{ true}}\ \wedge_{E1}
\qquad
\frac{A \wedge B\hbox{ true}}{B\hbox{ true}}\ \wedge_{E2}
</math>
</div>
As an example of the use of inference rules, consider commutativity of conjunction. If ''A ∧ B'' is true, then ''B ∧ A'' is true; This derivation can be drawn by composing inference rules in such a fashion that premises of a lower inference match the conclusion of the next higher inference.

<div style="margin-left: 2em">
<!-- there are serious vertical spacing issues here, but since Wikipedia's texvc parser doesn't support \displaystyle, our hands are tied somewhat -->
<math>
 \cfrac{\cfrac{A \wedge B\hbox{ true}}{B\hbox{ true}}\ \wedge_{E2} 
 \qquad
 \cfrac{A \wedge B\hbox{ true}}{A\hbox{ true}}\ \wedge_{E1}}
 {B \wedge A\hbox{ true}}\ \wedge_I
</math>
</div>

The inference figures we have seen so far are not sufficient to state the rules of implication introduction or disjunction elimination; for these, we need a more general notion of ''hypothetical derivation''.

==Hypothetical derivations==
A pervasive operation in mathematical logic is ''reasoning from assumptions''. For example, consider the following derivation:
<div style="margin-left: 2em">
<math>
\cfrac{A \wedge \left ( B \wedge C \right ) \ true}{\cfrac{B \wedge C \ true}{B \ true} \wedge_{ E_1}} \wedge_{ E_2}
</math>
</div>
This derivation does not establish the truth of ''B'' as such; rather, it establishes the following fact:
:If ''A ∧ (B ∧ C) is true'' then ''B is true''.
In logic, one says "''assuming A ∧ (B ∧ C) is true, we show that B is true''"; in other words, the judgement "''B true''" depends on the assumed judgement "''A ∧ (B ∧ C) true''". This is a ''hypothetical derivation'', which we write as follows:
<div style="margin-left: 2em">
<math>
\begin{matrix}
A \wedge \left ( B \wedge C \right ) \ true \\
\vdots \\
B \ true
\end{matrix}
</math>
</div>
The interpretation is: "''B true'' is derivable from ''A ∧ (B ∧ C) true''". Of course, in this specific example we actually know the derivation of "''B true''" from "''A ∧ (B ∧ C) true''", but in general we may not ''a-priori'' know the derivation. The general form of a hypothetical derivation is:
<div style="margin-left: 2em">
<math>
\begin{matrix}
D_1 \quad D_2 \cdots D_n \\
\vdots \\
J
\end{matrix}
</math>
</div>
Each hypothetical derivation has a collection of ''antecedent'' derivations (the ''D<sub>i</sub>'') written on the top line, and a ''succedent'' judgement (''J'') written on the bottom line. Each of the premises may itself be a hypothetical derivation. (For simplicity, we treat a judgement as a premise-less derivation.)

The notion of hypothetical judgement is ''internalised'' as the connective of implication. The introduction and elimination rules are as follows.
<div style="margin-left: 2em">
<math>
\cfrac{
 \begin{matrix}
 \cfrac{}{A \ true} u \\
 \vdots \\
 B \ true
 \end{matrix}
}{A \supset B \ true} \supset_{I^u}
\qquad \cfrac{A \supset B \ true \quad A \ true}{B \ true} \supset_E
</math>
</div>

In the introduction rule, the antecedent named ''u'' is ''discharged'' in the conclusion. This is a mechanism for delimiting the ''scope'' of the hypothesis: its sole reason for existence is to establish "''B true''"; it cannot be used for any other purpose, and in particular, it cannot be used below the introduction. As an example, consider the derivation of "''A ⊃ (B ⊃ (A ∧ B)) true''":
<div style="margin-left: 2em">
<math>
 \cfrac{\cfrac{\cfrac{{}}{A \ true} u \quad \cfrac{{}}{B \ true} w}{A \wedge B \ true}\wedge_I}{
 \cfrac{B \supset \left ( A \wedge B \right ) \ true}{
 A \supset \left ( B \supset \left ( A \wedge B \right ) \right ) \ true
 } \supset_{I^u}
 } \supset_{I^w}
 </math>
</div>
This full derivation has no unsatisfied premises; however, sub-derivations ''are'' hypothetical. For instance, the derivation of "''B ⊃ (A ∧ B) true''" is hypothetical with antecedent "''A true''" (named ''u'').

With hypothetical derivations, we can now write the elimination rule for disjunction:
<div style="margin-left: 2em">
<math>
\cfrac{
 A \vee B \hbox{ true}
 \quad
 \begin{matrix}
 \cfrac{}{A \ true} u \\
 \vdots \\
 C \ true
 \end{matrix}
 \quad
 \begin{matrix}
 \cfrac{}{B \ true} w \\
 \vdots \\
 C \ true
 \end{matrix}
}{C \ true} \vee_{E^{u,w}}
</math>
</div>
In words, if ''A ∨ B'' is true, and we can derive ''C true'' both from ''A true'' and from ''B true'', then ''C'' is indeed true. Note that this rule does not commit to either ''A true'' or ''B true''. In the zero-ary case, ''i.e.'' for falsehood, we obtain the following elimination rule:
<div style="margin-left: 2em">
<math>
\frac{\perp true}{C \ true} \perp_E
</math>
</div>
This is read as: if falsehood is true, then any proposition ''C'' is true.

Negation is similar to implication.
<div style="margin-left: 2em">
<math>
\cfrac{
 \begin{matrix}
 \cfrac{}{A \ true} u \\
 \vdots \\
 p \ true
 \end{matrix}
}{\lnot A \ true} \lnot_{I^{u,p}}
\qquad
\cfrac{\lnot A \ true \quad A \ true}{C \ true} \lnot _E
</math>
</div>
The introduction rule discharges both the name of the hypothesis ''u'', and the succedent ''p'', ''i.e.'', the proposition ''p'' must not occur in the conclusion '' A''. Since these rules are schematic, the interpretation of the introduction rule is: if from "''A true''" we can derive for every proposition ''p'' that "''p true''", then ''A'' must be false, ''i.e.'', "''not A true''". For the elimination, if both ''A'' and ''not A'' are shown to be true, then there is a contradiction, in which case every proposition ''C'' is true. Because the rules for implication and negation are so similar, it should be fairly easy to see that ''not A'' and ''A ⊃ ⊥'' are equivalent, i.e., each is derivable from the other.

==Consistency, completeness, and normal forms==
A [[theory (mathematics)#Mathematical theories|theory]] is said to be consistent if falsehood is not provable (from no assumptions) and is complete if every theorem is provable using the inference rules of the logic. These are statements about the entire logic, and are usually tied to some notion of a [[model theory|model]]. However, there are local notions of consistency and completeness that are purely syntactic checks on the inference rules, and require no appeals to models. The first of these is local consistency, also known as local reducibility, which says that any derivation containing an introduction of a connective followed immediately by its elimination can be turned into an equivalent derivation without this detour. It is a check on the ''strength'' of elimination rules: they must not be so strong that they include knowledge not already contained in its premises. As an example, consider conjunctions.
<table style="margin-left: 2em;"><tr><td>
 ------ u   ------ w
 A true     B true
 ------------------ ∧I
     A ∧ B true
     ---------- ∧E<sub>1</sub>
       A true
</td><td width="30" align="center">⇒</td><td>
 ------ u
 A true
</td></tr></table>

Dually, local completeness says that the elimination rules are strong enough to decompose a connective into the forms suitable for its introduction rule. Again for conjunctions:
<table style="margin-left: 2em;"><tr><td>
 ---------- u
 A ∧ B true
</td><td width="30" align="center">⇒</td><td>
 ---------- u    ---------- u
 A ∧ B true      A ∧ B true
 ---------- ∧E<sub>1</sub>   ---------- ∧E<sub>2</sub>
   A true           B true
   ----------------------- ∧I
        A ∧ B true
</td></tr></table>

These notions correspond exactly to [[Lambda_calculus#.CE.B2-reduction|β-reduction (beta reduction)]] and [[Lambda_calculus#.CE.B7-conversion|η-conversion (eta conversion)]] in the [[lambda calculus]], using the [[Curry&ndash;Howard isomorphism]]. By local completeness, we see that every derivation can be converted to an equivalent derivation where the principal connective is introduced. In fact, if the entire derivation obeys this ordering of eliminations followed by introductions, then it is said to be ''normal''. In a normal derivation all eliminations happen above introductions. In most logics, every derivation has an equivalent normal derivation, called a ''normal form''. The existence of normal forms is generally hard to prove using natural deduction alone, though such accounts do exist in the literature, most notably by [[Dag Prawitz]] in 1961; see his book ''Natural deduction: a proof-theoretical study'', A&W Stockholm 1965, no ISBN. It is much easier to show this indirectly by means of a [[cut elimination|cut-free]] [[sequent calculus]] presentation.

==First and higher-order extensions==
[[File:first order natural deduction.png|thumb|right|Summary of first-order system]]

The logic of the earlier section is an example of a ''single-sorted'' logic, ''i.e.'', a logic with a single kind of object: propositions. Many extensions of this simple framework have been proposed; in this section we will extend it with a second sort of ''individuals'' or ''terms''. More precisely, we will add a new kind of judgement, "''t is a term''" (or "''t term''") where ''t'' is schematic. We shall fix a [[countable]] set ''V'' of ''variables'', another countable set ''F'' of ''function symbols'', and construct terms as follows:
<table style="margin-left: 2em;"><tr><td>
 v ∈ V
 ------ var-F
 v term
</td><td width="10%"></td><td>
 f ∈ F    t<sub>1</sub> term    t<sub>2</sub> term  ...  t<sub>n</sub> term
 ------------------------------------------ app-F
      f (t<sub>1</sub>, t<sub>2</sub>, ..., t<sub>n</sub>) term
</td></tr></table>
For propositions, we consider a third countable set ''P'' of ''predicates'', and define ''atomic predicates over terms'' with the following formation rule:
<table style="margin-left: 2em;"><tr><td>
 φ ∈ P    t<sub>1</sub> term    t<sub>2</sub> term   ...   t<sub>n</sub> term
 ------------------------------------------ pred-F
      φ (t<sub>1</sub>, t<sub>2</sub>, ..., t<sub>n</sub>) prop
</td></tr></table>
In addition, we add a pair of ''quantified'' propositions: universal (∀) and existential (∃):
<table style="margin-left: 2em;"><tr><td>
   ------ u
   x term
     {{Unicode|⋮}}
   A prop
 ---------- ∀F<sup>u</sup>
 ∀x. A prop
</td><td width="10%"></td><td>
   ------ u
   x term
     {{Unicode|⋮}}
   A prop
 ---------- ∃F<sup>u</sup>
 ∃x. A prop
</td></tr></table>
These quantified propositions have the following introduction and elimination rules.

<table style="margin-left: 2em;"><tr><td>
   ------ u
   a term
     {{Unicode|⋮}}
 [a/x] A true
 ------------ ∀I<sup>u, a</sup>
 ∀x. A true
</td><td width="10%"></td><td>
 ∀x. A true t term
 -------------------- ∀E
 [t/x] A true
</td></tr><tr><td>
 [t/x] A true
 ------------ ∃I
  ∃x. A true
</td><td width="10%"></td><td>
                ------ u  ------------ v
                a term    [a/x] A true
                       {{Unicode|⋮}}
 ∃x. A true          C true
 -------------------------- ∃E<sup>a, u,v</sup>
            C true
</td></tr></table>
In these rules, the notation [''t''/''x''] ''A'' stands for the substitution of ''t'' for every (visible) instance of ''x'' in ''A'', avoiding capture; see the article on [[lambda calculus]] for more detail about this standard operation. As before the superscripts on the name stand for the components that are discharged: the term ''a'' cannot occur in the conclusion of ∀I (such terms are known as ''eigenvariables'' or ''parameters''), and the hypotheses named ''u'' and ''v'' in ∃E are localised to the second premise in a hypothetical derivation. Although the propositional logic of earlier sections was [[Decidability (logic)|decidable]], adding the quantifiers makes the logic undecidable.

So far the quantified extensions are ''first-order'': they distinguish propositions from the kinds of objects quantified over. Higher-order logic takes a different approach and has only a single sort of propositions. The quantifiers have as the domain of quantification the very same sort of propositions, as reflected in the formation rules:
<table style="margin-left: 2em;"><tr><td>
   ------ u
   p prop
     {{Unicode|⋮}}
   A prop
 ---------- ∀F<sup>u</sup>
 ∀p. A prop
</td><td width="10%"></td><td>
   ------ u
   p prop
     {{Unicode|⋮}}
   A prop
 ---------- ∃F<sup>u</sup>
 ∃p. A prop
</td></tr></table>
A discussion of the introduction and elimination forms for higher-order logic is beyond the scope of this article. It is possible to be in between first-order and higher-order logics. For example, second-order logic has two kinds of propositions, one kind quantifying over terms, and the second kind quantifying over propositions of the first kind.

==Different presentations of natural deduction==
===Tree-like presentations===
Gentzen's discharging annotations used to internalise hypothetical judgment can be avoided by representing proofs as a tree of [[sequents]] ''Γ {{Unicode|⊢}}A'' instead of a tree of ''A true'' judgments.

===Sequential presentations===
Jaśkowski's representations of natural deduction led to different notations such as [[Fitch-style calculus]] (or Fitch's diagrams) or [[Patrick Suppes|Suppes]]' method of which e.g. [[John Lemmon|Lemmon]] gave a variant called [[system L (Lemmon)|system L]].

==Proofs and type-theory==
The presentation of natural deduction so far has concentrated on the nature of propositions without giving a formal definition of a ''proof''. To formalise the notion of proof, we alter the presentation of hypothetical derivations slightly. We label the antecedents with ''proof variables'' (from some countable set ''V'' of variables), and decorate the succedent with the actual proof. The antecedents or ''hypotheses'' are separated from the succedent by means of a ''[[Turnstile (symbol)|turnstile]]'' ({{Unicode|⊢}}). This modification sometimes goes under the name of ''localised hypotheses''. The following diagram summarises the change.
<table style="margin-left: 2em;"><tr><td>
 ---- u<sub>1</sub> ---- u<sub>2</sub> ... ---- u<sub>n</sub>
  J<sub>1</sub>      J<sub>2</sub>          J<sub>n</sub>
               {{Unicode|⋮}}
               J
</td><td width="10%" align="center">⇒</td><td>
 u<sub>1</sub>:J<sub>1</sub>, u<sub>2</sub>:J<sub>2</sub>, ..., u<sub>n</sub>:J<sub>n</sub> {{Unicode|⊢}} J
</td></tr></table>
The collection of hypotheses will be written as Γ when their exact composition is not relevant.
To make proofs explicit, we move from the proof-less judgement "''A true''" to a judgement: "π ''is a proof of (A true)''", which is written symbolically as "π : ''A true''". Following the standard approach, proofs are specified with their own formation rules for the judgement "π ''proof''". The simplest possible proof is the use of a labelled hypothesis; in this case the evidence is the label itself.
<table style="margin-left: 2em;"><tr><td>
 u ∈ V
 ------- proof-F
 u proof
</td><td width="10%"></td><td>
 --------------------- hyp
 u:A true {{Unicode|⊢}} u : A true
</td></tr></table>
For brevity, we shall leave off the judgemental label ''true'' in the rest of this article, ''i.e.'', write "Γ {{Unicode|⊢}} π : ''A''". Let us re-examine some of the connectives with explicit proofs. For conjunction, we look at the introduction rule ∧I to discover the form of proofs of conjunction: they must be a pair of proofs of the two conjuncts. Thus:
<table style="margin-left: 2em;"><tr><td>
 π<sub>1</sub> proof    π<sub>2</sub> proof
 -------------------- pair-F
 (π<sub>1</sub>, π<sub>2</sub>) proof
</td><td width="10%"></td><td>
 Γ {{Unicode|⊢}} π<sub>1</sub> : A    Γ {{Unicode|⊢}} π<sub>2</sub> : B
 ------------------------ ∧I
 Γ {{Unicode|⊢}} (π<sub>1</sub>, π<sub>2</sub>) : A ∧ B
</td></tr></table>
The elimination rules ∧E<sub>1</sub> and ∧E<sub>2</sub> select either the left or the right conjunct; thus the proofs are a pair of projections &mdash; first ('''fst''') and second ('''snd''').
<table style="margin-left: 2em;"><tr><td>
 π proof
 ----------- '''fst'''-F
 '''fst''' π proof
</td><td width="10%"></td><td>
 Γ {{Unicode|⊢}} π : A ∧ B
 ------------- ∧E<sub>1</sub>
 Γ {{Unicode|⊢}} '''fst''' π : A
</td></tr><tr><td>
 π proof
 ----------- '''snd'''-F
 '''snd''' π proof
</td><td width="10%"></td><td>
 Γ {{Unicode|⊢}} π : A ∧ B
 ------------- ∧E<sub>2</sub>
 Γ {{Unicode|⊢}} '''snd''' π : B
</td></tr></table>
For implication, the introduction form localises or ''binds'' the hypothesis, written using a λ; this corresponds to the discharged label. In the rule, "Γ, ''u'':''A''" stands for the collection of hypotheses Γ, together with the additional hypothesis ''u''.
<table style="margin-left: 2em;"><tr><td>
 π proof
 ------------ λ-F
 λu. π proof
</td><td width="10%"></td><td>
 Γ, u:A {{Unicode|⊢}} π : B
 ----------------- ⊃I
 Γ {{Unicode|⊢}} λu. π : A ⊃ B
</td></tr><tr><td>
 π<sub>1</sub> proof   π<sub>2</sub> proof
 ------------------- app-F
 π<sub>1</sub> π<sub>2</sub> proof
</td><td width="10%"></td><td>
 Γ {{Unicode|⊢}} π<sub>1</sub> : A ⊃ B    Γ {{Unicode|⊢}} π<sub>2</sub> : A
 ---------------------------- ⊃E
 Γ {{Unicode|⊢}} π<sub>1</sub> π<sub>2</sub> : B
</td></tr></table>
With proofs available explicitly, one can manipulate and reason about proofs. The key operation on proofs is the substitution of one proof for an assumption used in another proof. This is commonly known as a ''substitution theorem'', and can be proved by [[mathematical induction|induction]] on the depth (or structure) of the second judgement.

; Substitution theorem : ''If'' Γ {{Unicode|⊢}} π<sub>1</sub> : ''A'' ''and'' Γ, ''u'':''A'' {{Unicode|⊢}} π<sub>2</sub> : ''B'', ''then'' Γ {{Unicode|⊢}} [π<sub>1</sub>/''u''] π<sub>2</sub> : B.

So far the judgement "Γ {{Unicode|⊢}} π : ''A''" has had a purely logical interpretation. In [[type theory]], the logical view is exchanged for a more computational view of objects. Propositions in the logical interpretation are now viewed as ''types'', and proofs as programs in the [[lambda calculus]]. Thus the interpretation of "π : ''A''" is "''the program'' π has type ''A''". The logical connectives are also given a different reading: conjunction is viewed as product (×), implication as the function arrow (→), etc. The differences are only cosmetic, however. Type theory has a natural deduction presentation in terms of formation, introduction and elimination rules; in fact, the reader can easily reconstruct what is known as ''simple type theory'' from the previous sections.

The difference between logic and type theory is primarily a shift of focus from the types (propositions) to the programs (proofs). Type theory is chiefly interested in the convertibility or reducibility of programs. For every type, there are canonical programs of that type which are irreducible; these are known as ''canonical forms'' or ''values''. If every program can be reduced to a canonical form, then the type theory is said to be ''normalising'' (or ''weakly normalising''). If the canonical form is unique, then the theory is said to be ''strongly normalising''. Normalisability is a rare feature of most non-trivial type theories, which is a big departure from the logical world. (Recall that every logical derivation has an equivalent normal derivation.) To sketch the reason: in type theories that admit recursive definitions, it is possible to write programs that never reduce to a value; such looping programs can generally be given any type. In particular, the looping program has type ⊥, although there is no logical proof of "⊥ ''true''". For this reason, the ''propositions as types; proofs as programs'' paradigm only works in one direction, if at all: interpreting a type theory as a logic generally gives an inconsistent logic.

Like logic, type theory has many extensions and variants, including first-order and higher-order versions. An interesting branch of type theory, known as [[dependent type theory]], allows quantifiers to range over programs themselves. These quantified types are written as Π and Σ instead of ∀ and ∃, and have the following formation rules:
<table style="margin-left: 2em;"><tr><td>
 Γ {{Unicode|⊢}} A type    Γ, x:A {{Unicode|⊢}} B type
 ----------------------------- Π-F
 Γ {{Unicode|⊢}} Πx:A. B type
</td><td width="10%"></td><td>
 Γ {{Unicode|⊢}} A type  Γ, x:A {{Unicode|⊢}} B type
 ---------------------------- Σ-F
 Γ {{Unicode|⊢}} Σx:A. B type
</td></tr></table>
These types are generalisations of the arrow and product types, respectively, as witnessed by their introduction and elimination rules.
<table style="margin-left: 2em;"><tr><td>
 Γ, x:A {{Unicode|⊢}} π : B
 -------------------- ΠI
 Γ {{Unicode|⊢}} λx. π : Πx:A. B
</td><td width="10%"></td><td>
 Γ {{Unicode|⊢}} π<sub>1</sub> : Πx:A. B   Γ {{Unicode|⊢}} π<sub>2</sub> : A
 ----------------------------- ΠE
 Γ {{Unicode|⊢}} π<sub>1</sub> π<sub>2</sub> : [π<sub>2</sub>/x] B
</td></tr></table>
<table style="margin-left: 2em;"><tr><td>
 Γ {{Unicode|⊢}} π<sub>1</sub> : A    Γ, x:A {{Unicode|⊢}} π<sub>2</sub> : B
 ----------------------------- ΣI
 Γ {{Unicode|⊢}} (π<sub>1</sub>, π<sub>2</sub>) : Σx:A. B
</td><td width="10%"></td><td>
 Γ {{Unicode|⊢}} π : Σx:A. B
 ---------------- ΣE<sub>1</sub>
 Γ {{Unicode|⊢}} '''fst''' π : A
</td><td width="10%"></td><td>
 Γ {{Unicode|⊢}} π : Σx:A. B
 ------------------------ ΣE<sub>2</sub>
 Γ {{Unicode|⊢}} '''snd''' π : ['''fst''' π/x] B
</td></tr></table>
Dependent type theory in full generality is very powerful: it is able to express almost any conceivable property of programs directly in the types of the program. This generality comes at a steep price &mdash; checking that a given program is of a given type is undecidable. For this reason, dependent type theories in practice do not allow quantification over arbitrary programs, but rather restrict to programs of a given decidable ''index domain'', for example integers, strings, or linear programs.

Since dependent type theories allow types to depend on programs, a natural question to ask is whether it is possible for programs to depend on types, or any other combination. There are many kinds of answers to such questions. A popular approach in type theory is to allow programs to be quantified over types, also known as ''parametric polymorphism''; of this there are two main kinds: if types and programs are kept separate, then one obtains a somewhat more well-behaved system called ''predicative polymorphism''; if the distinction between program and type is blurred, one obtains the type-theoretic analogue of higher-order logic, also known as ''impredicative polymorphism''. Various combinations of dependency and polymorphism have been considered in the literature, the most famous being the [[lambda cube]] of [[Henk Barendregt]].

The intersection of logic and type theory is a vast and active research area. New logics are usually formalised in a general type theoretic setting, known as a [[logical framework]]. Popular modern logical frameworks such as the [[calculus of constructions]] and [[LF (logical framework)|LF]] are based on higher-order dependent type theory, with various trade-offs in terms of decidability and expressive power. These logical frameworks are themselves always specified as natural deduction systems, which is a testament to the versatility of the natural deduction approach.

==Classical and modal logics==
For simplicity, the logics presented so far have been [[intuitionistic logic|intuitionistic]]. [[Classical logic]] extends intuitionistic logic with an additional [[axiom]] or principle of [[excluded middle]]:

:''For any proposition p, the proposition p ∨ ¬p is true.''

This statement is not obviously either an introduction or an elimination; indeed, it involves two distinct connectives. Gentzen's original treatment of excluded middle prescribed one of the following three (equivalent) formulations, which were already present in analogous forms in the systems of [[David Hilbert|Hilbert]] and [[Arend Heyting|Heyting]]:

<table style="margin-left: 2em;"><tr><td>
 -------------- XM<sub>1</sub>
 A ∨ ¬A true
</td><td width="5%"></td><td>
 ¬¬A true
 ---------- XM<sub>2</sub>
 A true
</td><td width="5%"></td><td>
 -------- ''u''
 ¬A true
 {{Unicode|⋮}}
 ''p'' true
 ------ XM<sub>3</sub><sup>''u, p''</sup>
 A true
</td></tr></table>

(XM<sub>3</sub> is merely XM<sub>2</sub> expressed in terms of E.) This treatment of excluded middle, in addition to being objectionable from a purist's standpoint, introduces additional complications in the definition of normal forms.

A comparatively more satisfactory treatment of classical natural deduction in terms of introduction and elimination rules alone was first proposed by [[Michel Parigot|Parigot]] in 1992 in the form of a classical [[lambda calculus]] called [[Lambda-mu calculus|λμ]]. The key insight of his approach was to replace a truth-centric judgement ''A true'' with a more classical notion, reminiscent of the [[sequent calculus]]: in localised form, instead of Γ {{Unicode|⊢}} ''A'', he used Γ {{Unicode|⊢}} Δ, with Δ a collection of propositions similar to Γ. Γ was treated as a conjunction, and Δ as a disjunction. This structure is essentially lifted directly from classical [[sequent calculus|sequent calculi]], but the innovation in λμ was to give a computational meaning to classical natural deduction proofs in terms of a [[callcc]] or a throw/catch mechanism seen in [[LISP]] and its descendants. (See also: [[first class control]].)

Another important extension was for [[modal logic|modal]] and other logics that need more than just the basic judgement of truth. These were first described, for the alethic modal logics S4 and S5, in a natural deduction style by [[Dag Prawitz|Prawitz]] in 1965, and have since accumulated a large body of related work. To give a simple example, the modal logic S4 requires one new judgement, "''A valid''", that is categorical with respect to truth:

:''If "A true" under no assumptions of the form "B true", then "A valid".''

This categorical judgement is internalised as a unary connective {{Unicode|◻}}''A'' (read "''necessarily A''") with the following introduction and elimination rules:

<table style="margin-left: 2em;"><tr><td>
 A valid
 -------- {{Unicode|◻}}I
 {{Unicode|◻}} A true
</td><td width="5%"></td><td>
 {{Unicode|◻}} A true
 -------- {{Unicode|◻}}E
 A true
</td></tr></table>

Note that the premise "''A valid''" has no defining rules; instead, the categorical definition of validity is used in its place. This mode becomes clearer in the localised form when the hypotheses are explicit. We write "Ω;Γ {{Unicode|⊢}} ''A true''" where Γ contains the true hypotheses as before, and Ω contains valid hypotheses. On the right there is just a single judgement "''A true''"; validity is not needed here since "Ω {{Unicode|⊢}} ''A valid''" is by definition the same as "Ω;{{Unicode|⋅}} {{Unicode|⊢}} ''A true''". The introduction and elimination forms are then:
<table style="margin-left: 2em;"><tr><td>
 Ω;{{Unicode|⋅}} {{Unicode|⊢}} π : A true
 -------------------- {{Unicode|◻}}I
 Ω;{{Unicode|⋅}} {{Unicode|⊢}} '''box''' π : {{Unicode|◻}} A true
</td><td width="5%"></td><td>
 Ω;Γ {{Unicode|⊢}} π : {{Unicode|◻}} A true
 ---------------------- {{Unicode|◻}}E
 Ω;Γ {{Unicode|⊢}} '''unbox''' π : A true
</td></tr></table>

The modal hypotheses have their own version of the hypothesis rule and substitution theorem.

<table style="margin-left: 2em;"><tr><td>
 ------------------------------- valid-hyp
 Ω, u: (A valid) ; Γ {{Unicode|⊢}} u : A true
</td></tr></table>

; Modal substitution theorem : ''If'' Ω;{{Unicode|⋅}} {{Unicode|⊢}} π<sub>1</sub> : ''A true'' ''and'' Ω, ''u'': (''A valid'') ; Γ {{Unicode|⊢}} π<sub>2</sub> : ''C true'', ''then'' Ω;Γ {{Unicode|⊢}} [π<sub>1</sub>/''u''] π<sub>2</sub> : ''C true''.

This framework of separating judgements into distinct collections of hypotheses, also known as ''multi-zoned'' or ''polyadic'' contexts, is very powerful and extensible; it has been applied for many different modal logics, and also for [[linear logic|linear]] and other [[substructural logic]]s, to give a few examples.  However, relatively few systems of modal logic can be formalised directly in natural deduction; to give proof-theoretic characterisations of these systems, extensions such as labelling,<ref>The addition of labels to formulae permits much finer control of the conditions under which  rules apply, allowing the more flexible techniques of [[analytic tableu]]x to be applied, as has been done in the case of [[labelled deduction]].  Labels also allow the naming of worlds in Kripke semantics; Simpson (1993) presents an influential technique for converting frame conditions of modal logics in Kripke semantics into inference rules in a natural deduction formalisation of [[hybrid logic]].</ref> or systems of deep inference<ref>Stouppa (2004) surveys the application of many proof theories, such as Avron and Pottinger's [[hypersequent]]s and Belnap's [[display logic]] to such modal logics as S5 and B.</ref>

==Comparison with other foundational approaches==
===Sequent calculus===
{{Main|Sequent calculus}}

The sequent calculus is the chief alternative to natural deduction as a foundation of [[mathematical logic]]. In natural deduction the flow of information is bi-directional: elimination rules flow information downwards by deconstruction, and introduction rules flow information upwards by assembly. Thus, a natural deduction proof does not have a purely bottom-up or top-down reading, making it unsuitable for automation in proof search, or even for proof checking (or type-checking in type theory). To address this fact, [[Gerhard Gentzen|Gentzen]] in 1935 proposed his [[sequent calculus]], though he initially intended it as a technical device for clarifying the consistency of [[predicate logic]]. [[Stephen Cole Kleene|Kleene]], in his seminal 1952 book ''Introduction to Metamathematics'' (ISBN 0-7204-2103-9), gave the first formulation of the sequent calculus in the modern style.

In the sequent calculus all inference rules have a purely bottom-up reading. Inference rules can apply to elements on both sides of the [[Turnstile (symbol)|turnstile]]. (To differentiate from natural deduction, this article uses a double arrow ⇒ instead of the right tack {{Unicode|⊢}} for sequents.) The introduction rules of natural deduction are viewed as ''right rules'' in the sequent calculus, and are structurally very similar. The elimination rules on the other hand turn into ''left rules'' in the sequent calculus. To give an example, consider disjunction; the right rules are familiar:
<table style="margin-left: 2em;"><tr><td>
 Γ ⇒ A
 --------- ∨R<sub>1</sub>
 Γ ⇒ A ∨ B
</td><td with="10%"></td><td>
 Γ ⇒ B
 --------- ∨R<sub>2</sub>
 Γ ⇒ A ∨ B
</td></tr></table>
On the left:
<table style="margin-left: 2em;"><tr><td>
 Γ, u:A ⇒ C       Γ, v:B ⇒ C
 --------------------------- ∨L
 Γ, w: (A ∨ B) ⇒ C
</td></tr></table>
Recall the ∨E rule of natural deduction in localised form:
<table style="margin-left: 2em;"><tr><td>
 Γ {{Unicode|⊢}} A ∨ B    Γ, u:A {{Unicode|⊢}} C    Γ, v:B {{Unicode|⊢}} C
 --------------------------------------- ∨E
 Γ {{Unicode|⊢}} C
</td></tr></table>
The proposition ''A ∨ B'', which is the succedent of a premise in ∨E, turns into a hypothesis of the conclusion in the left rule ∨L. Thus, left rules can be seen as a sort of inverted elimination rule. This observation can be illustrated as follows:
<table align="center">
<tr><th>natural deduction</th><td></td><th>sequent calculus</th></tr>
<tr><td>
 ------ hyp
 |
 | elim. rules
 |
 ↓
 ---------------------- ↑↓ meet
 ↑
 |
 | intro. rules
 |
 conclusion
</td><td width="20%" align="center">⇒</td><td>
 --------------------------- init
 ↑            ↑
 |            |
 | left rules | right rules
 |            |
 conclusion
</td></tr></table>
In the sequent calculus, the left and right rules are performed in lock-step until one reaches the ''initial sequent'', which corresponds to the meeting point of elimination and introduction rules in natural deduction. These initial rules are superficially similar to the hypothesis rule of natural deduction, but in the sequent calculus they describe a ''transposition'' or a ''handshake'' of a left and a right proposition:
<table style="margin-left: 2em;"><tr><td>
 ---------- init
 Γ, u:A ⇒ A
</td></tr></table>
The correspondence between the sequent calculus and natural deduction is a pair of soundness and completeness theorems, which are both provable by means of an inductive argument.

; Soundness of ⇒ wrt. {{Unicode|⊢}} : ''If'' Γ ⇒ ''A'', ''then'' Γ {{Unicode|⊢}} ''A''.
; Completeness of ⇒ wrt. {{Unicode|⊢}} : ''If'' Γ {{Unicode|⊢}} ''A'', ''then'' Γ ⇒ ''A''.

It is clear by these theorems that the sequent calculus does not change the notion of truth, because the same collection of propositions remain true. Thus, one can use the same proof objects as before in sequent calculus derivations. As an example, consider the conjunctions. The right rule is virtually identical to the introduction rule
<table style="margin-left: 2em;">
<tr><th>sequent calculus</th><td></td><th>natural deduction</th></tr>
<tr><td>
 Γ ⇒ π<sub>1</sub> : A     Γ ⇒ π<sub>2</sub> : B
 --------------------------- ∧R
 Γ ⇒ (π<sub>1</sub>, π<sub>2</sub>) : A ∧ B
</td><td width="20%"></td><td>
 Γ {{Unicode|⊢}} π<sub>1</sub> : A      Γ {{Unicode|⊢}} π<sub>2</sub> : B
 ------------------------- ∧I
 Γ {{Unicode|⊢}} (π<sub>1</sub>, π<sub>2</sub>) : A ∧ B
</td></tr>
</table>
The left rule, however, performs some additional substitutions that are not performed in the corresponding elimination rules.
<table style="margin-left: 2em;">
<tr><th>sequent calculus</th><td></td><th>natural deduction</th></tr>
<tr><td>
 Γ, v: (A ∧ B), u:A ⇒ π : C
 -------------------------------- ∧L<sub>1</sub>
 Γ, v: (A ∧ B) ⇒ ['''fst''' v/u] π : C
</td><td width="20%"></td><td>
 Γ {{Unicode|⊢}} π : A ∧ B
 ------------- ∧E<sub>1</sub>
 Γ {{Unicode|⊢}} '''fst''' π : A
</td></tr>
<tr><td>
 Γ, v: (A ∧ B), u:B ⇒ π : C
 -------------------------------- ∧L<sub>2</sub>
 Γ, v: (A ∧ B) ⇒ ['''snd''' v/u] π : C
</td><td width="20%"></td><td>
 Γ {{Unicode|⊢}} π : A ∧ B
 ------------- ∧E<sub>2</sub>
 Γ {{Unicode|⊢}} '''snd''' π : B
</td></tr>
</table>

The kinds of proofs generated in the sequent calculus are therefore rather different from those of natural deduction. The sequent calculus produces proofs in what is known as the ''β-normal η-long'' form, which corresponds to a canonical representation of the normal form of the natural deduction proof. If one attempts to describe these proofs using natural deduction itself, one obtains what is called the ''intercalation calculus'' (first described by John Byrnes [3]), which can be used to formally define the notion of a ''normal form'' for natural deduction.

The substitution theorem of natural deduction takes the form of a [[structural rule]] or structural theorem known as ''cut'' in the sequent calculus.

; Cut (substitution) : ''If'' Γ ⇒ π<sub>1</sub> : ''A'' ''and'' Γ, ''u'':''A'' ⇒ π<sub>2</sub> : ''C'', ''then'' Γ ⇒ [π<sub>1</sub>/u] π<sub>2</sub> : ''C''.

In most well behaved logics, cut is unnecessary as an inference rule, though it remains provable as a meta-theorem; the superfluousness of the cut rule is usually presented as a computational process, known as ''cut elimination''. This has an interesting application for natural deduction; usually it is extremely tedious to prove certain properties directly in natural deduction because of an unbounded number of cases. For example, consider showing that a given proposition is ''not'' provable in natural deduction. A simple inductive argument fails because of rules like ∨E or E which can introduce arbitrary propositions. However, we know that the sequent calculus is complete with respect to natural deduction, so it is enough to show this unprovability in the sequent calculus. Now, if cut is not available as an inference rule, then all sequent rules either introduce a connective on the right or the left, so the depth of a sequent derivation is fully bounded by the connectives in the final conclusion. Thus, showing unprovability is much easier, because there are only a finite number of cases to consider, and each case is composed entirely of sub-propositions of the conclusion. A simple instance of this is the ''global consistency'' theorem: "{{Unicode|⋅}} {{Unicode|⊢}} ⊥ ''true''" is not provable. In the sequent calculus version, this is manifestly true because there is no rule that can have "{{Unicode|⋅}} ⇒ ⊥" as a conclusion! Proof theorists often prefer to work on cut-free sequent calculus formulations because of such properties.
<!--

TODO

==Comparison with other foundational approaches==
===Hilbert-style axiomatic systems===
===Combinatorial approaches===
Compare with the [[Calculus of Structures]], [[Display Logic]]s, and [[Proof-Net]]s.

===Categorical and model-theoretic approaches===
-->

== See also ==
{{Col-begin}}
{{Col-1-of-3}}

{{Col-2-of-3}}

{{Col-3-of-3}}
{{Portal|Logic}}
{{Col-end}}

==Notes==
{{Reflist}}

==References==
===Historical references===

* Stanaslaw Jaśkowski, 1934. ''On the Rules of Suppositions in Formal Logic''.
* Gerhard Gentzen, 1934/5. ''Untersuchungen uber das logische Schließen'' (English translation ''Investigations into Logical Deduction'' in Szabo)

=== Textbooks, surveys and co ===

*[[Jon Barwise]] and [[John Etchemendy]], 2000. ''Language Proof and Logic''. CSLI (University of Chicago Press) and New York: Seven Bridges Press. A gentle introduction to [[first-order logic]] via natural deduction, by two first rate logicians.
* Jean Gallier's excellent tutorial on Constructive Logic and Typed Lambda-Calculi, ftp://ftp.cis.upenn.edu/pub/papers/gallier/conslog1.ps.
* {{cite book
 | author = [[Jean-Yves Girard]]
 | url = http://www.cs.man.ac.uk/~pt/stable/Proofs+Types.html
 | publisher = Cambridge University Press, Cambridge, England
 | series = Cambridge Tracts in Theoretical Computer Science
 | title = Proofs and Types
 | year = 1990
}} Translated and with appendices by Paul Taylor and Yves Lafont.
* {{cite journal
 | author=[[Per Martin-Löf]]
 | url = http://docenti.lett.unisi.it/files/4/1/1/6/martinlof4.pdf
 | title = On the meanings of the logical constants and the justifications of the logical laws
 | journal=Nordic Journal of Philosophical Logic
 | volume=1 | issue=1 | year=1996 | pages=11–60
 }} Lecture notes to a short course at Università degli Studi di Siena, April 1983.

=== Other references ===

* {{cite journal
 | author=Frank Pfenning and Rowan Davies
 | url = http://www-2.cs.cmu.edu/~fp/papers/mscs00.pdf
 | title = A judgmental reconstruction of modal logic
 | journal=Mathematical Structures in Computer Science
 | volume=11 | issue=4 | year=2001 | pages=511–540
 | doi = 10.1017/S0960129501003322
 }}
* Alex Simpson, 1993.  ''The Proof Theory and Semantics of Intuitionistic Modal Logic''.  PhD thesis, University of Edinburgh.
* Phiniki Stouppa, 2004.  The Design of Modal Proof Theories: The Case of S5.  MSc thesis, University of Dresden.

==External links==
* Clemente, Daniel, "[http://www.danielclemente.com/logica/dn.en.pdf Introduction to natural deduction.]"
* [http://www.winterdrache.de/freeware/domino/ Domino On Acid.] Natural deduction visualized as a game of dominoes.
* Pelletier, Jeff, "[http://www.sfu.ca/~jeffpell/papers/pelletierNDtexts.pdf A History of Natural Deduction and Elementary Logic Textbooks.]"
* Levy, Michel, [http://teachinglogic.liglab.fr/DN/ A Propositional Prover.]

{{logic}}

{{DEFAULTSORT:Natural Deduction}}
[[Category:Logical calculi]]
[[Category:Deduction]]
[[Category:Proof theory]]

{{Link GA|zh}}

[[de:Systeme natürlichen Schließens]]
[[es:Deducción natural]]
[[fr:Déduction naturelle]]
[[nl:Natuurlijke deductie]]
[[ja:自然演繹]]
[[pl:Dedukcja naturalna]]
[[pt:Dedução natural]]
[[fi:Luonnollinen päättely]]
[[zh:自然演绎]]</body> </html>