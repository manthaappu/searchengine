<html> <head> <title>Variable (programming)</title></head><body>{{Refimprove|date=November 2009}}

In [[computer programming]], a '''variable''' is a symbolic name given to some known or unknown quantity or information, for the purpose of allowing the name to be used independently of the information it represents. A variable name in computer [[source code]] is usually associated with a [[Memory address|data storage location]] and thus also its contents, and these may change during the course of program execution.

Variables in programming may not directly correspond to the concept of [[Variable (mathematics)|variables in mathematics]]. The value of a computing variable is not necessarily part of an [[equation]] or [[formula]] as in mathematics.  In computing, a variable may be employed in a repetitive process: assigned a value in one place, then used elsewhere, then reassigned a new value and used again in the same way.  (See [[Iteration#Computing|iteration]].)  Variables in computer programming are frequently given long names to make them relatively descriptive of their use, whereas variables in mathematics often have terse, one- or two-character names for brevity in transcription and manipulation.

A computer variable can represent any kind of [[Data (computing)|data]] that can be stored in the computer system, from simple true/false conditions to numbers, names, pictures, sounds, segments of audio/video or arrays of information describing multi-dimensional [[object|entities]] (e.g., within [[computer models]]), or even to further computer code or behaviour such as [[subroutine]]s and [[First-class function|functions]].  Variables in business computing may represent numerical quantities such as monetary amounts, counters, totals and subtotals; alphanumeric [[Field (computer science)|fields]] containing names and descriptions of persons, places or products; or complex [[data structure]]s representing compound [[Object (computer science)|objects]] such as clients, investments, [[Account (accountancy)|accounts]], meetings or legal matters.

A variable has three essential attributes: a symbolic name (also known as an [[identifier]]), a data location (generally in storage or memory, identified by [[address]] and [[length]]), and a [[value (computer science)|value]], represented by the data contents of that location.  These attributes are often assigned at separate times during the program execution. In some programming languages, non-identical identifiers can simultaneously refer to the same variable, location and value.

Variables often also have a fourth attribute, a [[Data type|type]] which specifies the kind of information the variable stores.  Variable type defines the format in which its value is to be stored, the amount of memory it occupies and the way its contents can be manipulated and expressed.  A variable can be typed as a [[Scalar (computing)|scalar]] or [[Array data type|array]], or as a more specific subtype (e.g., integer, currency, string, boolean, etc.), or as any other object or [[Class (computer science)|class]] of objects defined elsewhere, depending on what is supported by the [[programming language]].

[[compiler (computing)|Compilers]] and [[Interpreter (computing)|interpreters]] of computer code have to replace the variables' symbolic names by the actual locations of the data.  While the variable name, type and location generally remain fixed, the data stored in the location may alter during program execution.

==Identifiers referencing a variable==

An identifier referencing a variable can be used to access the variable in order to read out the value, or alter the value, or modify the [[Attribute (computing)|attributes]] of the variable, such as access permission, [[Lock (computer science)|locks]], [[Semaphore (programming)|semaphores]], etc.

For instance, a variable might be referenced by the identifier "<code>total_count</code>" and the variable can contain the number 1956.  If the same variable is referenced by the identifier "<code>x</code>" as well, and if using this identifier "<code>x</code>", the value of the variable is altered to 2009, then reading the value using the identifier "<code>total_count</code>", the result is 2009 and not 1956.

If in a particular programming language a variable can only be referenced by a single identifier, that can simply be called ''the name of the variable''.  Otherwise we can talk about ''one of the names of the variable''.  For instance, in the previous example, the "<code>total_count</code>" is a name of the variable in question, and "<code>x</code>" is another name of the same variable.

==Actions on a variable==

In [[imperative programming|imperative]] [[programming language]]s, values can generally be [[Dereference|accessed]] or [[Assignment (computer science)|changed]] at any time. However, in [[Pure function|pure]] [[functional programming|functional]] and [[logic programming|logic language]]s, variables are [[Free variables and bound variables|bound]] to expressions and keep a single value during their entire [[Scope (programming)|lifetime]] due to the requirements of [[referential transparency (computer science)|referential transparency]]. In imperative languages, the same behavior is exhibited by [[constant (programming)|constant]]s, which are typically contrasted with normal variables.

Depending on the [[type system]] of a programming language, variables may only be able to store a specified [[datatype]] (e.g. [[Integer (computer science)|integer]] or [[string (computer science)|string]]). Alternatively a datatype may be associated only with the current value, allowing a single variable to store anything supported by the programming language.

==Naming conventions==
{{Main|Naming conventions (programming)}}
{{See also|Identifier|Namespace (computer science)}}

Unlike their mathematical counterparts, programming variables and constants commonly take multiple-character names, e.g. <code>COST</code> or <code>total</code>. Single-character names are most commonly used only for auxiliary variables; for instance, <code>i</code>, <code>j</code>, <code>k</code> for [[Array data type|array]] index variables.

Some naming conventions are enforced at the language level as part of the language syntax and involve the format of valid identifiers. In almost all languages, variable names cannot start with a digit (0-9) and cannot contain whitespace characters. Whether, which, and when punctuation marks are permitted in variable names varies from language to language; many languages only permit the underscore (_) in variable names and forbid all other punctuation. In some programming languages, specific (often punctuation) characters (known as [[sigil (computer programming)|sigil]]s) are prefixed or appended to variable identifiers to indicate the variable's type.

[[Case-sensitivity]] of variable names also varies between languages and some languages require the use of a certain case in naming certain entities;<ref group="note">For example, [[Haskell (programming language)|Haskell]] requires that names of types start with a capital letter.</ref>  Most modern languages are case-sensitive, some older languages are not. Some languages reserve certain forms of variable names for their own internal use; in many languages, names beginning with 2 underscores ("__") often fall under this category.

However, beyond the basic restrictions imposed by a language, the naming of variables is largely a matter of style. At the machine code level, variable names are not used, so the exact names chosen do not matter to the computer. Thus names of variables identify them, for the rest they are just a tool for programmers to make programs easier to write and understand.

Programmers often create and adhere to code style guidelines which offer guidance on naming variables or impose a precise naming scheme. Shorter names are faster to type but are less descriptive; longer names often make programs easier to read and the purpose of variables easier to understand. However, extreme verbosity in variable names can also lead to less comprehensible code.

==In spreadsheets==
In a [[spreadsheet]], a cell may contain a [[formula]] with [[cell reference|references to other cells]]. Such a cell reference is a kind of variable; its value is the value of the referenced cell (see also: [[reference (computer science)]]).

==Scope and extent==
<!-- Note: Please do not change this header, cross-referenced from [[scope (programming)]]. -->
{{See also|Free variables and bound variables}}
The ''[[scope (programming)|scope]]'' of a variable describes where in a program's text, the variable may be used, while the ''extent'' (or ''lifetime'') describes when in a program's execution a variable has a (meaningful) value. The scope of a variable is actually a property of the name of the variable, and the extent is a property of the variable itself.

A variable name's ''scope'' affects its ''extent''.

''Scope'' is a [[Lexical variable scoping#Static scoping|lexical]] aspect of a variable. Most languages define a specific ''scope'' for each variable (as well as any other named entity), which may differ within a given program. The scope of a variable is the portion of the program code for which the variable's name has meaning and for which the variable is said to be "visible". Entrance into that scope typically begins a variable's lifetime and exit from that scope typically ends its lifetime. For instance, a variable with "lexical scope" is meaningful only within a certain block of statements or [[subroutine]]. Variables only accessible within a certain functions are termed "[[local variable]]s". A "[[global variable]]", or one with indefinite scope, may be referred to anywhere in the program.

''Extent'', on the other hand, is a runtime ([[Dynamic variable scoping#Dynamic scoping|dynamic]]) aspect of a variable. Each [[name binding|binding]] of a variable to a value can have its own ''extent'' at runtime. The extent of the binding is the portion of the program's execution time during which the variable continues to refer to the same value or memory location. A running program may enter and leave a given extent many times, as in the case of a [[closure (computer science)|closure]].

In portions of code, a variable in scope may never have been given a value, or its value may have been destroyed. Such variables are described as "out of extent" or "unbound". In many languages, it is an error to try to use the value of a variable when it is out of extent. In other languages, doing so may yield [[undefined behavior|unpredictable results]]. Such a variable may, however, be assigned a new value, which gives it a new extent. By contrast, it is permissible for a variable binding to extend beyond its scope, as occurs in Lisp closures and C [[Local variable#Static local variables|static local variable]]s. When execution passes back into the variable's scope, the variable may once again be used.

For space efficiency, a memory space needed for a variable may be allocated only when the variable is first used and freed when it is no longer needed. A variable is only needed when it is in scope, but beginning each variable's lifetime when it enters scope may give space to unused variables. To avoid wasting such space, compilers often warn programmers if a variable is declared but not used.

It is considered good programming practice to make the scope of variables as narrow as feasible so that different parts of a program do not accidentally interact with each other by modifying each other's variables. Doing so also prevents [[action at distance (computer science)|action at a distance]].  Common techniques for doing so are to have different sections of a program use different [[namespace (programming)|namespace]]s, or to make individual variables "private" through either [[Dynamic variable scoping#Dynamic scoping|dynamic variable scoping]] or [[Lexical variable scoping#Static scoping|lexical variable scoping]].

Many programming languages employ a reserved value (often named ''[[null pointer|null]]'' or ''nil'') to indicate an invalid or uninitialized variable.

==Typing==
{{Main|Type system}}
{{See also|Datatype}}
In [[static typing|statically-typed]] languages such as [[Java (programming language)|Java]] or [[ML programming language|ML]], a variable also has a ''type'', meaning that only values of a given class (or set of classes) can be stored in it. A variable of a [[Primitive data type|primitive]] type holds a value of that exact primitive type. A variable of a class type can hold a null reference or a reference to an object whose type is that class type or any subclass of that class type. A variable of an interface type can hold a null reference or a reference to an instance of any class that implements the interface. A variable of an array type can hold a null reference or a reference to an array.

In [[dynamic typing|dynamically-typed]] languages such as [[Python (programming language)|Python]], it is values, not variables, which carry type. In [[Common Lisp]], both situations exist simultaneously: a variable is given a type (if undeclared, it is assumed to be <code>T</code>, the universal [[Subtype|supertype]]) which exists at compile time. Values also have types, which can be checked and queried at runtime.

Typing of variables also allows [[type polymorphism|polymorphisms]] to be resolved at compile time. However, this is different from the polymorphism used in object-oriented function calls (referred to as ''[[virtual functions]]'' in [[C++]]) which resolves the call based on the value type as opposed to the supertypes the variable is allowed to have.

Variables often store simple data-like integers and literal strings, but some programming languages allow a variable to store values of other [[datatype]]s as well. Such languages may also enable functions to be [[Parametric polymorphism#Parametric polymorphism|parametric polymorphic]]. These functions operate like variables to represent data of multiple types. For example, a function named <code>length</code> may determine the length of a list. Such a <code>length</code> function may be parametric polymorphic by including a type variable in its [[type signature]], since the amount of elements in the list is independent of the elements' types.

==Parameters==
The ''formal parameters'' of functions are also referred to as variables. For instance, in this [[Python (programming language)|Python]] code segment,

 <source lang="python">
 def addtwo(x):
    return x + 2

 addtwo(5)  # yields 7
 </source>

The variable named <code>x</code> is a ''parameter'' because it is given a value when the function is called.  The integer 5 is the ''argument'' which gives <code>x</code> its value. In most languages, function parameters have local scope {{Citation needed|date=October 2007}}. This specific variable named <code>x</code> can only be referred to within the <code>addtwo</code> function (though of course other functions can also have variables called <code>x</code>).

==Memory allocation==
The specifics of variable allocation and the representation of their values vary widely, both among programming languages and among implementations of a given language. Many language implementations allocate space for ''[[local variable]]s'', whose extent lasts for a single function call on the ''[[call stack]]'', and whose memory is automatically reclaimed when the function returns. (More generally, in ''[[name binding]]'', the name of a variable is bound to the address of some particular block (contiguous sequence) of bytes in memory, and operations on the variable manipulate that block. [[reference (computer science)|Referencing]] is more common for variables whose values have large or unknown sizes when the code is compiled. Such variables reference the location of the value instead of the storing value itself, which is allocated from a pool of memory called the ''[[Dynamic memory allocation#Heap-based memory allocation|heap]]''.

Bound variables have values. A value, however, is an abstraction, an idea; in implementation, a value is represented by some ''[[Object (computer science)|data object]]'', which is stored somewhere in computer memory. The program, or the runtime environment, must set aside memory for each data object and, since memory is finite, ensure that this memory is yielded for reuse when the object is no longer needed to represent some variable's value.

Objects allocated from the heap must be reclaimed&mdash;especially when the objects are no longer needed. In a [[garbage collection (computer science)|garbage-collected]] language (such as [[C Sharp (programming language)|C#]], [[Java (programming language)|Java]], and [[Lisp (programming language)|Lisp]]), the runtime environment automatically reclaims objects when extant variables can no longer refer to them. In non-garbage-collected languages, such as [[C (programming language)|C]], the program (and the programmer) must explicitly [[malloc|allocate]] memory, and then later free it, to reclaim its memory. Failure to do so leads to [[memory leak]]s, in which the heap is depleted as the program runs, risking eventual failure from exhausting available memory.

When a variable refers to a [[data structure]] created dynamically, some of its components may be only indirectly accessed through the variable. In such circumstances, garbage collectors (or analogous program features in languages that lack garbage collectors) must deal with a case where only a portion of the memory reachable from the variable needs to be reclaimed.

==Interpolation==<!--
####
EDITOR NOTE: The header text for this section is directly linked by other articles.
Please do not change the header text unless you know what links here and can make
the appropriate fixes.
####
-->
'''Variable interpolation''' (also '''variable substitution''' or '''variable expansion''') is the process of evaluating an expression or string literal containing one or more variables, yielding a result in which the variables are replaced with their corresponding values in memory. It is a specialized instance of [[concatenation]].

Languages that support variable interpolation include [[Perl]], [[PHP]], [[Ruby (programming language)|Ruby]], [[Tcl]] and most [[Unix shell]]s. In these languages, variable interpolation only occurs when the string literal is double-quoted, but not when it is single-quoted. The variables are recognized because variables start with a [[sigil (computer programming)|sigil]] (typically "$") in these languages.

For example, the following [[Perl]] code (which would work identically in [[PHP]]):
<source lang="perl">
$name = "Nakul";
print "${name} said Hello World to the crowd of people.";
</source>
produces the output:
<pre>
Nakul said Hello World to the crowd of people.
</pre>

[[Ruby (programming language)|Ruby]] uses the "#" symbol for interpolation, and lets you interpolate any expression, not just variables.  Other languages may support more advanced interpolation with a special formatting function, such as [[printf]], in which the first argument, the ''format'', specifies the pattern in which the remaining arguments are substituted.

==Notes==
{{Reflist|group=note}}

{{DEFAULTSORT:Variable (Programming)}}
[[Category:Variable (computer programming)|*]]
[[Category:Variables]]
[[Category:Data types]]
[[Category:Type theory]]

[[bs:Promjenljiva]]
[[de:Variable (Programmierung)]]
[[es:Variable (programación)]]
[[fr:Variable (informatique)]]
[[hr:Promjenjiva]]
[[it:Variabile (informatica)]]
[[he:משתנה (תכנות)]]
[[nl:Variabele (informatica)]]
[[ja:変数 (プログラミング)]]
[[pl:Zmienna (informatyka)]]
[[pt:Variável (programação)]]
[[ru:Переменная (программирование)]]
[[sk:Premenná (informatika)]]
[[fi:Muuttuja (ohjelmointi)]]
[[uk:Змінна]]</body> </html>