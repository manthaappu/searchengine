<html> <head> <title>SHA-2</title></head><body>{{Infobox cryptographic hash function
| name           = SHA-2
| image          = 
| caption        = 
<!-- General -->
| designers      = [[National Security Agency]]
| publish date   = 2001
| series         = (SHA-0), [[SHA-1]], SHA-2
| derived from   = 
| derived to     = 
| related to     = 
| certification  = [[Federal Information Processing Standard|FIPS]] PUB 180-2
<!-- Detail -->
| digest size    = 224/256 bits or 384/512 bits
| structure      = [[Merkle–Damgård construction]]
| rounds         = 64 or 80
| cryptanalysis  = A 2008 attack breaks [[preimage resistance]] for 46 out of 80 rounds of SHA-512, and 42 out of 64 rounds of SHA-256.<ref name=preimage-sasaki>{{Cite journal |author=Yu Sasaki, Lei Wang, and Kazumaro Aoki |date=2008-11-25 |title=Preimage Attacks on 41-Step SHA-256 and 46-Step SHA-512 |url=http://eprint.iacr.org/2009/479.pdf }}</ref>
Collision attacks against up to 24 steps of SHA-256<ref name=preimage-sasaki>{{Cite journal |author=Somitra Kumar Sanadhya and Palash Sarkar|date=2008|title=New Collision attacks Against Up To 24-step SHA-2|http://eprint.iacr.org/2008/270.pdf}}</ref>
}}
{{Portal|Cryptography}}
In cryptography, '''SHA-2''' is a set of [[cryptographic hash function]]s ('''SHA-224, SHA-256, SHA-384, SHA-512''') designed by the [[National Security Agency]] (NSA) and published in 2001 by the [[National Institute of Standards and Technology|NIST]] as a U.S. [[Federal Information Processing Standard]]. SHA stands for '''Secure Hash Algorithm'''. SHA-2 includes a significant number of changes from its predecessor, [[SHA-1]]. SHA-2 consists of a set of four hash functions with digests that are 224, 256, 384 or 512 bits.

In 2005, security flaws were identified in SHA-1, namely that a mathematical weakness might exist, indicating that a stronger hash function would be desirable.<ref>[http://www.schneier.com/blog/archives/2005/02/cryptanalysis_o.html Schneier on Security: Cryptanalysis of SHA-1<!-- Bot generated title -->]</ref> Although SHA-2 bears some similarity to the SHA-1 algorithm, these attacks have not been successfully extended to SHA-2.

A new hash standard, SHA-3, is currently under development &mdash; an ongoing [[NIST hash function competition]] is scheduled to end with the selection of a winning function in 2012. The SHA-3 algorithm will not be derived from SHA-2.

==Hash function==
[[File:SHA-2.svg|thumbnail|right|400px|One iteration in a SHA-2 family compression function.
The blue components perform the following operations: <br />
<math>Ch(E,F,G) = (E \or F) \oplus (\neg E \or G)</math>
<math>Ma(A,B,C) = (A \or B) \oplus (A \or C) \oplus (B \or C)</math>
<math>\Sigma_0(A) = (A\!\ggg\!2) \oplus (A\!\ggg\!13) \oplus (A\!\ggg\!22)</math>
<math>\Sigma_1(E) = (E\!\ggg\!6) \oplus (E\!\ggg\!11) \oplus (E\!\ggg\!25)</math> <br />
The bitwise rotation uses different constants for SHA-512. The given numbers are for SHA-256.
The red <math>\boxplus</math> is an addition with no carry.
]]
NIST published four additional hash functions in the SHA family, named after their digest lengths (in bits): SHA-224, SHA-256, SHA-384, and SHA-512. The algorithms are collectively known as SHA-2.

The algorithms were first published in 2001 in the draft FIPS PUB 180-2, at which time review and comments were accepted. FIPS PUB 180-2, which also includes SHA-1, was released as an official standard in 2002. In February 2004, a change notice was published for FIPS PUB 180-2, specifying an additional variant, SHA-224, defined to match the key length of two-key [[Triple DES]]. These variants are patented in {{cite patent|US|6829355}}. The [[United States]] has released the patent under a royalty free license.<ref>{{cite journal |title=Licensing Declaration for US patent 6829355.|url=https://datatracker.ietf.org/ipr/858/|accessdate=2008-02-17}}</ref>

SHA-256 and SHA-512 are novel hash functions computed with 32- and 64-bit words, respectively. They use different shift amounts and additive constants, but their structures are otherwise virtually identical, differing only in the number of rounds. SHA-224 and SHA-384 are simply truncated versions of the first two, computed with different initial values.

The SHA-2 functions are not as widely used as SHA-1, despite their better security. Reasons might include lack of support for SHA-2 on systems running Windows XP SP2 or older,<ref>Microsoft Corporation, [http://download.microsoft.com/download/6/8/7/687484ed-8174-496d-8db9-f02b40c12982/Overview%20of%20Windows%20XP%20Service%20Pack%203.pdf Overview of Windows XP Service Pack 3]</ref> a lack of perceived urgency since SHA-1 collisions have not yet been found, or a desire to wait until [[NIST hash function competition|SHA-3]] is standardized. SHA-256 is used to authenticate [[Debian]] Linux software packages<ref>[http://google.com/codesearch/p?hl=en#nywQboHfkw4/apt/apt-pkg/acquire-item.cc&q=SHA256 Debian codebase in Google Code]</ref> and in the [[DKIM]] message signing standard; SHA-512 is part of a system to authenticate archival video from the [[International Criminal Tribunal for Rwanda|International Criminal Tribunal of the Rwandan genocide]].<ref>John Markoff, [http://www.nytimes.com/2009/01/27/science/27arch.html A Tool to Verify Digital Records, Even as Technology Shifts], ''New York Times'', January 26, 2009</ref> SHA-256 and SHA-512 are proposed for use in [[DNSSEC]].<ref>RFC 5702,[http://www.rfc-editor.org/rfc/rfc5702.txt RFC-Editor.org]</ref>  Unix and Linux vendors are moving to using 256- and 512-bit SHA-2 for secure password hashing.<ref>Ulrich Drepper, [http://people.redhat.com/drepper/sha-crypt.html Unix crypt with SHA-256/512]</ref> NIST's directive that U.S. government agencies must stop uses of SHA-1 after 2010<ref>{{cite web
 | url=http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html
 | title=Secure Hashing - NIST Computer Security Division - Computer Security Resource Center
 | work=[[NIST]]
 | accessdate=2010-11-25 }}
</ref>, and the completion of SHA-3, may accelerate migration away from SHA-1.

Currently, the best public attacks break 41 of the 64 rounds of SHA-256 or 46 of the 80 rounds of SHA-512, as discussed in [[#SHA-2|the "Cryptanalysis and Validation" section below]].<ref>Yu Sasaki, Lei Wang, and Kazumaro Aoki, [http://eprint.iacr.org/2009/479.pdf Preimage Attacks on 41-Step SHA-256 and 46-Step SHA-512], accessed 3 Jan 2010</ref>

==Comparison of SHA functions==
In the table below, ''internal state'' means the “internal hash sum” after each compression of a data block.
{{See|Merkle–Damgård construction}}

{| border=1 class="wikitable"
! colspan="2" | Algorithm and <br />variant
!Output size (bits)
!Internal state size (bits)
!Block size (bits)
!Max message size (bits)
!Word size (bits)
!Rounds
!Operations
![[Hash collision|Collisions]] found
|- align="center"
| colspan="2" | '''SHA-0''' || 160 || 160 || 512 || 2<sup>64</sup> − 1 || 32 || 80 || +,and,or,xor,rot || Yes
|- align="center"
| colspan="2" | '''SHA-1''' || 160 || 160 || 512 || 2<sup>64</sup> − 1 || 32 || 80 || +,and,or,xor,rot || Yes (2<sup>51</sup>)<ref>[http://eprint.iacr.org/2008/469.pdf Classification and Generation of Disturbance Vectors for Collision Attacks against SHA-1]</ref>
|- align="center"
| rowspan="2" | '''SHA-2''' || ''SHA-256/224'' || 256/224 || 256 || 512 || 2<sup>64</sup> − 1 || 32 || 64 || +,and,or,xor,shr,rot || None
|- align="center"
| ''SHA-512/384'' || 512/384 || 512 || 1024 || 2<sup>128</sup> − 1 || 64 || 80 || +,and,or,xor,shr,rot || None
|}

==Applications==
{{details|Cryptographic hash function#Applications}}
The SHA-2 hash function is implemented in some widely-used security applications and protocols, including [[Transport Layer Security|TLS]] and [[Secure Sockets Layer|SSL]], [[Pretty Good Privacy|PGP]], [[Secure Shell|SSH]], [[S/MIME]], and [[IPsec]]. Those applications can also use [[SHA-1]] and [[MD5]].

SHA-1 and SHA-2 are the secure hash algorithms required by law for use in certain [[U.S. Government]] applications, including use within other cryptographic algorithms and protocols, for the protection of sensitive unclassified information. FIPS PUB 180-1 also encouraged adoption and use of SHA-1 by private and commercial organizations. SHA-1 is being retired for most government uses; the U.S. National Institute of Standards and Technology says, "Federal agencies '''''should''''' stop using SHA-1 for...applications that require collision resistance as soon as practical, and must use the SHA-2 family of hash functions for these applications after 2010" (emphasis in original).<ref>National Institute on Standards and Technology Computer Security Resource Center, [http://csrc.nist.gov/groups/ST/hash/policy.html NIST's Policy on Hash Functions], accessed March 29, 2009.</ref>

==Cryptanalysis and validation==
For a hash function for which ''L'' is the number of [[bits]] in the [[message digest]], finding a message that corresponds to a given message digest can always be done using a [[brute force]] search in 2<sup>''L''</sup> evaluations. This is called a [[preimage attack]] and may or may not be practical depending on ''L'' and the particular computing environment. The second criterion, finding two different messages that produce the same message digest, known as a [[Collision (computer science)|collision]], requires on average only 2<sup>''L''/2</sup> evaluations using a [[birthday attack]].

In terms of practical security, a major concern about these new attacks is that they might pave the way to more efficient ones. Whether this is the case has yet to be seen, but a migration to stronger hashes is believed to be prudent. Some of the applications that use cryptographic hashes, such as password storage, are only minimally affected by a collision attack. Constructing a password that works for a given account requires a preimage attack, as well as access to the hash of the original password (typically in the ''shadow'' file) which may or may not be trivial. Reversing password encryption (e.g., to obtain a password to try against a user's account elsewhere) is not made possible by the attacks. (However, even a secure password hash cannot prevent brute-force attacks on [[password strength|weak passwords]].)

In the case of document signing, an attacker could not simply fake a signature from an existing document—the attacker would have to produce a pair of documents, one innocuous and one damaging, and get the private key holder to sign the innocuous document. There are practical circumstances in which this is possible; until the end of 2008, it was possible to create forged [[Transport Layer Security|SSL]] certificates using an [[MD5]] collision.<ref>Alexander Sotirov, Marc Stevens,
Jacob Appelbaum, Arjen Lenstra, David Molnar, Dag Arne Osvik, Benne de Weger, [http://www.win.tue.nl/hashclash/rogue-ca/ MD5 considered harmful today: Creating a rogue CA certificate], accessed March 29, 2009</ref>

There are two [[Meet-in-the-middle attack|meet-in-the-middle]] [[preimage attack]]s against SHA-2 with a reduced number of rounds. The first one attacks 41-round SHA-256 out of 64 rounds with time complexity of 2<sup>253.5</sup> and space complexity of 2<sup>16</sup>, and 46-round SHA-512 out of 80 rounds with time 2<sup>511.5</sup> and space 2<sup>3</sup>.<ref name=preimage-sasaki /> The second one attacks 42-round SHA-256 with time complexity of 2<sup>251.7</sup> and space complexity of 2<sup>12</sup>, and 42-round SHA-512 with time 2<sup>502</sup> and space 2<sup>22</sup>.<ref name=preimage-guo>{{Cite journal |author=Jian Guo, Krystian Matusiewicz |date=2008-11-25 |title=Preimages for Step-Reduced SHA-2 |url=http://eprint.iacr.org/2009/477.pdf }}</ref>

===Official validation===
{{Main|CMVP}}
Implementations of all FIPS-approved security functions can be officially validated through the [[CMVP|CMVP program]], jointly run by the [[National Institute of Standards and Technology]] (NIST) and the [[Communications Security Establishment]] (CSE). For informal verification, a package to generate a high number of test vectors is made available for download on the NIST site; the resulting verification however does not replace in any way the formal CMVP validation, which is required by law for certain applications.

For a list of example SHA-2 digests, see [[examples of SHA digests]].

===SHA-256 (a SHA-2 variant) pseudocode===
[[Pseudocode]] for the SHA-256 algorithm follows. Note the great increase in mixing between bits of the <code>w&#91;16..63&#93;</code> words compared to SHA-1.

 <span style="color: green;">''Note 1: All variables are unsigned 32 bits and wrap modulo 2<sup>32</sup> when calculating''</span>
 <span style="color: green;">''Note 2: All constants in this pseudo code are in <u>big endian</u></span>
 
 <span style="color:green;">''Initialize variables''</span>
 <span style="color:green;">(first 32 bits of the <em>fractional parts<em> of the square roots of the first 8 primes 2..19):</span>
 h0 := 0x6a09e667
 h1 := 0xbb67ae85
 h2 := 0x3c6ef372
 h3 := 0xa54ff53a
 h4 := 0x510e527f
 h5 := 0x9b05688c
 h6 := 0x1f83d9ab
 h7 := 0x5be0cd19
 
 <span style="color:green;">''Initialize table of round constants''</span>
 <span style="color:green;">(first 32 bits of the ''fractional parts'' of the cube roots of the first 64 primes 2..311):</span>
 k&#91;0..63&#93; :=
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
 
 <span style="color:green;">''Pre-processing:''</span>
 append the bit '1' to the message
 append k bits '0', where k is the minimum number >= 0 such that the resulting message
     length (in ''bits'') is [[modular arithmetic|congruent]] to 448 (mod 512)
 append length of message (before pre-processing), in ''bits'', as 64-bit big-endian integer
 
 <span style="color:green;">''Process the message in successive 512-bit chunks:''</span>
 break message into 512-bit chunks
 '''for''' each chunk
     break chunk into sixteen 32-bit big-endian words w&#91;0..15&#93;
 
     <span style="color:green;">''Extend the sixteen 32-bit words into sixty-four 32-bit words:''</span>
     '''for''' i '''from''' 16 to 63
         s0 := (w&#91;i-15&#93; '''rightrotate''' 7) '''xor''' (w&#91;i-15&#93; '''rightrotate''' 18) '''xor''' (w&#91;i-15&#93; '''rightshift''' 3)
         s1 := (w&#91;i-2&#93; '''rightrotate''' 17) '''xor''' (w&#91;i-2&#93; '''rightrotate''' 19) '''xor''' (w&#91;i-2&#93; '''rightshift''' 10)
         w&#91;i&#93; := w&#91;i-16&#93; '''+''' s0 '''+''' w&#91;i-7&#93; '''+''' s1
 
     <span style="color:green;">''Initialize hash value for this chunk:''</span>
     a := h0
     b := h1
     c := h2
     d := h3
     e := h4
     f := h5
     g := h6
     h := h7
 
     <span style="color:green;">''Main loop:''</span>
     '''for''' i '''from''' 0 to 63
         s0 := (a '''rightrotate''' 2) '''xor''' (a '''rightrotate''' 13) '''xor''' (a '''rightrotate''' 22)
         maj := (a '''and''' b) '''xor''' (a '''and''' c) '''xor''' (b '''and''' c)
         t2 := s0 + maj
         s1 := (e '''rightrotate''' 6) '''xor''' (e '''rightrotate''' 11) '''xor''' (e '''rightrotate''' 25)
         ch := (e '''and''' f) '''xor''' (('''not''' e) '''and''' g)
         t1 := h + s1 + ch + k&#91;i&#93; + w&#91;i&#93;
 
         h := g
         g := f
         f := e
         e := d + t1
         d := c
         c := b
         b := a
         a := t1 + t2
 
     <span style="color:green;">''Add this chunk's hash to result so far:''</span>
     h0 := h0 + a
     h1 := h1 + b 
     h2 := h2 + c
     h3 := h3 + d
     h4 := h4 + e
     h5 := h5 + f
     h6 := h6 + g 
     h7 := h7 + h
 
 <span style="color:green;">''Produce the final hash value (big-endian):''</span>
 digest = hash = h0 '''append''' h1 '''append''' h2 '''append''' h3 '''append''' h4 '''append''' h5 '''append''' h6 '''append''' h7

The computation of the <code>ch</code> and <code>maj</code> values can be optimized the same way [[SHA-1#SHA-1 pseudocode|as described for SHA-1]].

SHA-224 is identical to SHA-256, except that:
* the initial variable values <code>h0</code> through <code>h7</code> are different, and
* the output is constructed by omitting <code>h7</code>.
 <span style="color:green;">Here the initial values for the variables (in big endian):</span>
 <span style="color:green;">(The second 32 bits of the fractional parts of the square roots of the 9th through 16th primes 23..53)</span>
 h0 := 0xc1059ed8
 h1 := 0x367cd507
 h2 := 0x3070dd17
 h3 := 0xf70e5939
 h4 := 0xffc00b31
 h5 := 0x68581511
 h6 := 0x64f98fa7
 h7 := 0xbefa4fa4

SHA-512 is identical in structure, but:
* all numbers are 64 bits long,
* there are 80 rounds instead of 64,
* the initial values and additive constants are extended to 64 bits, and
* the shift and rotate amounts used are different.

SHA-384 is identical to SHA-512, except that:
* the initial values <code>h0</code> through <code>h7</code> are different (taken from the 9th through 16th primes), and
* the output is constructed by omitting <code>h6</code> and <code>h7</code>.

==See also==
* [[Comparison of cryptographic hash functions]]
* [[Digital timestamping]]
* [[FORK-256]]
* [[Hash collision]]
* [[Hashcash]]
* [[International Association for Cryptologic Research]] (IACR)
* [[RIPEMD-160]]
* [[Secure Hash Standard]]
* <tt>[[sha1sum]]</tt> (sha224sum, sha256sum, sha384sum  and sha512sum)
* [[Tiger (cryptography)|Tiger]]
* [[Whirlpool (cryptography)|Whirlpool]]

==References==
{{Reflist|colwidth=30em}}
{{refbegin|colwidth=30em}}
* [[Henri Gilbert]], [[Helena Handschuh]]: Security Analysis of SHA-256 and Sisters. [[Selected Areas in Cryptography]] 2003: pp175–193
* {{cite journal|title=Proposed Revision of Federal Information Processing Standard (FIPS) 180, Secure Hash Standard|journal=Federal Register|date=1994-07-11|first=|last=|coauthors=|volume=59|issue=131|pages=35317–35318|id= |url=http://frwebgate1.access.gpo.gov/cgi-bin/waisgate.cgi?WAISdocID=5963452267+0+0+0&WAISaction=retrieve|format=|accessdate=2007-04-26}}
{{refend}}

==External links==
<!-- We suffer from a lot of self promotion here.
 --- Please do not add a link to your own site. See http://en.wikipedia.org/w/index.php?title=WP:COI
 --- It will be removed, and you may be blocked without further warning. -->

===Standards: SHA-1, SHA-2===
* [http://www.eff.org/Privacy/Digital_signature/?f=fips_sha_shs.standard.txt Specifications for a Secure Hash Standard (SHS)] – Draft for proposed SHS (SHA-0)
* [http://www.eff.org/Privacy/Digital_signature/?f=fips_sha_shs.info.txt Secure Hash Standard (SHS)] – Proposed SHS (SHA-0)
* [http://csrc.nist.gov/CryptoToolkit/tkhash.html CSRC Cryptographic Toolkit] – Official [[National Institute of Standards and Technology|NIST]] site for the Secure Hash Standard
** [http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf FIPS 180-3: Secure Hash Standard (SHS)] ([[Portable Document Format|PDF]], 236 kB) – Current version of the Secure Hash Standard (SHA-1, SHA-224, SHA-256, SHA-384, and SHA-512), October 2008
* [https://www.cosic.esat.kuleuven.be/nessie/testvectors/hash/sha/index.html Test vectors for SHA-256/384/512] from the [[NESSIE]] project
* [http://csrc.nist.gov/groups/STM/cavp/index.html#03 Test vectors for SHA-1, SHA-2] from [[National Institute of Standards and Technology|NIST]] site
* [http://www.csrc.nist.gov/groups/ST/hash/index.html NIST Cryptographic Hash Project] SHA-3 competition
* RFC 3874: A 224-bit One-way Hash Function: SHA-224.
* RFC 4634: US Secure Hash Algorithms (SHA and HMAC-SHA). Contains sample C implementation.

===Implementations===
<!-- This section should include only implementations that are commercially or algorithmically significant, such as those widely used in existing technologies and platforms -->
;[http://directory.fsf.org/project/libgcrypt/ Libgcrypt]: A general purpose cryptographic library based on the code from [[GNU Privacy Guard]].
;[[OpenSSL]]: The widely used OpenSSL <code>crypto</code> library includes [[free software|free]], [[open source|open-source]] – implementations of SHA-1, SHA-224, SHA-256, SHA-384, and SHA-512
;[[Crypto++]]: A public domain C++ class library of cryptographic schemes, including implementations of the SHA-1, SHA-224, SHA-256, SHA-384, and SHA-512 algorithms.
;[[Bouncy Castle (cryptography)|Bouncy Castle]]: The Bouncy Castle Library is a free Java and C# class library that contains implementations of the SHA-1, SHA-224, SHA-256, SHA-384 and SHA-512 algorithms as well as other algorithms like [[Whirlpool (cryptography)|Whirlpool]], [[Tiger (hash)|Tiger]], [[RIPEMD]], GOST-3411, [[MD2 (cryptography)|MD2]], [[MD4]] and [[MD5]].
;[http://jssha.sourceforge.net/ jsSHA]: A cross-browser [[JavaScript]] library for client-side calculation of SHA digests, despite the fact that JavaScript does not natively support the 64-bit operations required for SHA-384 and SHA-512.
;[http://libtom.org/?page=features&newsitems=5&whatfile=crypt LibTomCrypt]: A portable ISO C cryptographic toolkit, Public Domain.
;[[md5deep]]: A set of programs to compute MD5, SHA-1, SHA-256, Tiger, or Whirlpool cryptographic message digests on an arbitrary number of files. It is used in computer security, system administration and computer forensics communities for purposes of running large numbers of files through any of several different cryptographic digests. It is similar to [[sha1sum]] from [[GNU Core Utilities]] and [[md5sum]].

{{Crypto navbox|hash}}

{{DEFAULTSORT:Sha-2}}
[[Category:Cryptographic hash functions]]
[[Category:Articles with example pseudocode]]
[[Category:Checksum algorithms]]

[[hr:SHA-2]]</body> </html>