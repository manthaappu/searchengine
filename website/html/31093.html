<html> <head> <title>Rabin cryptosystem</title></head><body>The '''Rabin cryptosystem''' is an asymmetric [[cryptographic]] technique, whose security, like that of [[RSA]], is related to the difficulty of [[factorization]].  However the Rabin cryptosystem has the advantage that the problem on which it relies has been proved to be as hard as [[integer factorization]], which is not currently known to be true of the [[RSA|RSA problem]].  It has the disadvantage that each output of the Rabin function can be generated by any of four possible inputs; if each output is a ciphertext, extra complexity is required on decryption to identify which of the four possible inputs was the true plaintext.

==History==
The process was published in January 1979 by [[Michael O. Rabin]]. The Rabin cryptosystem was the first asymmetric cryptosystem where recovering the entire plaintext from the ciphertext could be proven to be as hard as factoring.

==Key generation==
As with all asymmetric cryptosystems, the Rabin system uses both a [[public key|public]] and a [[private key]]. The public key is necessary for later encoding and can be published, while the private key must be possessed only by the recipient of the message.

The precise key-generation process follows:

*Choose two large distinct primes ''p'' and ''q''. One may choose <math>p \equiv q \equiv 3 \pmod{4}</math> to simplify the computation of square roots modulo ''p'' and ''q'' (see below). But the scheme works with any primes.
*Let <math>n = p \cdot q</math>. Then ''n'' is the public key. The primes ''p'' and ''q'' are the private key. 

To encrypt a message only the public key ''n'' is needed. To decrypt a ciphertext
the factors ''p'' and ''q'' of ''n'' are necessary.

As a (non-real-world) example, if <math>p = 7</math> and <math>q = 11</math>, then <math>n=77</math>.  The public key, 77, would be released, and the message encoded using this key.  And, in order to decode the message, the private keys, 7 and 11, would have to be known (of course, this would be a poor choice of keys, as the factorization of 77 is trivial).

==Encryption==
For the encryption, only the public key ''n'' is used, thus producing a ciphertext out of the plaintext. The process follows:

Let <math>P = \{ 0, \dots, n-1 \}</math> be the plaintext space (consisting of numbers) and <math>m \in P</math> be the [[plaintext]]. Now the [[ciphertext]] <math>c</math> is determined by

:<math>c = m^2 \, \bmod \, n</math>.

That is, ''c'' is the quadratic remainder of the square of the plaintext, modulo the key-number ''n''. 

In our simple example, <math>P = \{ 0, \dots, 76 \}</math> is our plaintext space. We will take <math>m = 20</math> as our plaintext. The ciphertext is thus 
<math>c = m^2 \, \bmod \, n = 400 \, \bmod \, 77 = 15</math>.

For exactly four different values of ''m'', the ciphertext 15 is produced, i.e. for <math>m \in \{ 13, 20, 57, 64 \}</math>. This is true for most ciphertexts produced by the Rabin algorithm, i.e. it is a four-to-one function.

==Decryption==
To decode the ciphertext, the private keys are necessary. The process follows:

If ''c'' and ''r'' are known, the plaintext is then <math>m \in \{ 0, \dots, n-1 \}</math> with <math>m^2 \equiv c\pmod{r}</math>. For a [[Composite number|composite]] ''r'' (that is, like the Rabin algorithm's <math>n = p \cdot q</math>) there is no efficient method known for the finding of ''m''. If, however <math>r \in \mathbb{P}</math> (as are ''p'' and ''q'' in the Rabin algorithm), the [[Chinese remainder theorem]] can be applied to solve for ''m''.

Thus the [[square root]]s

:<math>m_p = \sqrt{c} \, \bmod \, p</math>

and

:<math>m_q = \sqrt{c} \, \bmod \, q</math>

must be calculated (see section below).

In our example we get <math>m_p = 1</math> and <math>m_q = 9</math>.

By applying the [[extended Euclidean algorithm]], <math>y_p</math> and <math>y_q</math>, with <math>y_p \cdot p + y_q \cdot q = 1</math> are calculated. In our example, we have <math>y_p = -3</math> and <math>y_q = 2</math>.

Now, by invocation of the Chinese remainder theorem, the four square roots <math>+r</math>, <math>-r</math>, <math>+s</math> and <math>-s</math> of <math>c + n \mathbb{Z} \in \mathbb{Z} / n \mathbb{Z}</math> are calculated (<math>\mathbb{Z} / n \mathbb{Z}</math> here stands for the [[modular arithmetic#Ring of congruence classes|ring of congruence classes]] modulo ''n''). The four square roots are in the set <math>\{ 0, \dots, n-1 \}</math>):
:<math>\begin{matrix}
r  & = & ( y_p \cdot p \cdot m_q + y_q \cdot q \cdot m_p) \, \bmod \, n  \\
-r & = & n - r  \\
s  & = & ( y_p \cdot p \cdot m_q - y_q \cdot q \cdot m_p) \, \bmod \, n  \\
-s & = & n - s 
\end{matrix}</math>

One of these square roots <math>\mod \, n</math> is the original plaintext ''m''. In our example, <math>m \in \{ 64, \mathbf{20}, 13, 57 \}</math>.

==Computing square roots==
The decryption requires to compute square roots of the ciphertext ''c'' modulo
the primes ''p'' and ''q''. Choosing <math>p \equiv q \equiv 3\pmod{4}</math> allows to compute square roots by 
:<math>m_p = c^{\frac{(p+1)}{4}} \, \bmod \, p</math>
and
:<math>m_q = c^{\frac{(q+1)}{4}} \, \bmod \, q</math>.
We can show that this method works for ''p'' as follows.
First <math>p \equiv 3\!\!\!\pmod{4}</math> implies that (''p''+1)/4 is an integer. The assumption is trivial for 
''c''≡0 (mod ''p''). Thus we may assume that ''p'' does not divide ''c''. Then
:<math>m_p^2 \equiv c^{\frac{(p+1)}{2}} \equiv c\cdot c^{\frac{(p-1)}{2}} \equiv c \cdot\left({c\over p}\right) \pmod{p},</math>
where <math>\left({c\over p}\right)</math> is a [[Legendre symbol]].
From <math>c\equiv m^2\pmod{pq}</math> follows that <math>c\equiv m^2\pmod{p}</math>. Thus ''c'' is a [[quadratic residue]] modulo ''p''. 
Hence <math>\left({c\over p}\right)=1</math> and therefore 
:<math>m_p^2 \equiv c \pmod{p}.</math> 
The relation <math>p \equiv 3\pmod{4}</math> is not a requirement because square roots modulo
other primes can be computed too. E.g. Rabin proposes to find the square roots modulo primes by using a special case of [[Berlekamp's algorithm]].

==Evaluation of the algorithm==
===Effectiveness===
Decoding produces three false results in addition to the correct one, so that the correct result must be guessed. This is the major disadvantage of the Rabin cryptosystem and one of the factors which have prevented it from finding widespread practical use.

If the plaintext is intended to represent a text message, guessing is not difficult; however, if the plaintext is intended to represent a numerical value, this issue becomes a problem that must be resolved by some kind of disambiguation scheme. It is possible to choose plaintexts with special structures, or to add [[padding (cryptography)|padding]], to eliminate this problem. A way of removing the ambiguity of inversion was suggested by Blum and Williams: the two primes used are restricted to primes congruent to 3 modulo 4 and the domain of the squaring is restricted to the set of quadratic residues. These restrictions make the squaring function into a [[Trapdoor function|trapdoor]] [[permutation]], eliminating the ambiguity.<ref>[[Shafi Goldwasser]] and [[Mihir Bellare]] [http://cseweb.ucsd.edu/~mihir/papers/gb.html "Lecture Notes on Cryptography"]. Summer course on cryptography, MIT, 1996-2001</ref>

===Efficiency===
For encryption, a square modulo ''n'' must be calculated. This is more efficient than [[RSA]], which requires the calculation of at least a cube.

For decryption, the [[Chinese remainder theorem]] is applied, along with two [[modular exponentiation]]s. Here the efficiency is comparable to RSA.

Disambiguation introduces additional computational costs, and is what has prevented the Rabin cryptosystem from finding widespread practical use.

===Security===
The great advantage of the Rabin cryptosystem is that a random plaintext can be recovered entirely from the ciphertext only if the codebreaker is capable of efficiently factoring the public key ''n''. Note that this is a very weak level of security. Extensions of the Rabin cryptosystem achieve stronger notions of security.

It has been proven that decoding the Rabin cryptosystem is equivalent to the integer factorization problem, which is rather different than for RSA. Thus the Rabin system is 'more secure' in this sense than is RSA, and will remain so until a general solution for the factorization problem is discovered, or until the RSA problem is discovered to be equivalent to factorization. (This assumes that the plaintext was not created with a specific structure to ease decoding.)

Since the solution to the factorization problem is being sought on many different fronts, any solution (outside classified research organizations such as [[NSA]]) would rapidly become available to the whole scientific community. However, a solution has been long in coming, and the factorization problem has been, thus, practically insoluble. Without such an advance, an attacker would have no chance today of breaking the code. This cryptosystem is provably secure (in a strong sense) against [[chosen plaintext]] attacks.

However, an active attacker can break the system using a [[chosen ciphertext attack]], as has been mathematically proven.

By adding redundancies, for example, the repetition of the last 64 bits, the system can be made to produce a single root. This thwarts the chosen-ciphertext attack, since the decoding algorithm then only produces the root that the attacker already knows. If this technique is applied, the proof of the equivalence with the factorization problem fails, so it is uncertain as of 2004 if this variant is secure. The [http://www.cacr.math.uwaterloo.ca/hac/ Handbook of Applied Cryptography] by Menezes, Oorschot and Vanstone considers this equivalence probable, however, as long as the finding of the roots remains a two-part process (1. roots <math>\mod p</math> and <math>\mod q</math> and 2. application of the Chinese remainder theorem).

Since in the encoding process, only the modulo remainders of perfect squares are used (in our example with <math>n = 77</math>, this is only 23 of the 76 possible values), other attacks on the process are possible.

==See also==
* [[Topics in cryptography]]
* [[Blum Blum Shub]]
* [[Shanks–Tonelli algorithm]]
* [[Schmidt–Samoa cryptosystem]]

==Notes==
{{reflist}}

==References==
* Buchmann, Johannes. ''Einführung in die Kryptographie''. Second Edition. Berlin: Springer, 2001. ISBN 3-540-41283-2
* Menezes, Alfred; van Oorschot, Paul C.; and Vanstone, Scott A. ''Handbook of Applied Cryptography''. CRC Press, October 1996. ISBN 0-8493-8523-7
* Rabin, Michael. ''[http://www.lcs.mit.edu/publications/pubs/pdf/MIT-LCS-TR-212.pdf Digitalized Signatures and Public-Key Functions as Intractable as Factorization]'' (in PDF). MIT Laboratory for Computer Science, January 1979.
* Scott Lindhurst, An analysis of Shank's algorithm for computing square  roots in finite fields. in R Gupta and K S Williams, Proc 5th Conf Can Nr Theo Assoc, 1999, vol 19 CRM Proc & Lec Notes, AMS, Aug 1999.
* R Kumanduri and C Romero, Number Theory w/ Computer Applications, Alg 9.2.9, Prentice Hall, 1997. A probabilistic for square root of a quadratic residue modulo a prime.

==External links==
* [http://www.cacr.math.uwaterloo.ca/hac/ Menezes, Oorschot, Vanstone, Scott: ''Handbook of Applied Cryptography'' (free PDF downloads), see Chapter 8]

{{Crypto navbox | public-key}}
[[Category:Public-key cryptography]]
[[Category: Asymmetric-key cryptosystems]]

[[de:Rabin-Kryptosystem]]
[[es:Criptosistema Rabin]]
[[fr:Cryptosystème de Rabin]]
[[it:Crittosistema di Rabin]]
[[he:הצפנת רבין]]
[[ja:Rabin暗号]]
[[pl:Algorytm Rabina]]
[[ru:Криптосистема Рабина]]</body> </html>