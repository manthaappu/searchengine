<html> <head> <title>Recursion</title></head><body>{{Other uses|Recursive (disambiguation){{!}}Recursive}}
{{No footnotes|date=February 2010}}
[[Image:Droste.jpg|thumb|A visual form of recursion known as the ''[[Droste effect]]''. The woman in this image is holding an object which contains a smaller image of her holding the same object, which in turn contains a smaller image of herself holding the same object, and so forth.]]
'''Recursion''' is the process of repeating items in a self-similar way. For instance, when the surfaces of two mirrors are exactly parallel with each other the nested images that occur are a form of infinite recursion. The term has a variety of meanings specific to a variety of disciplines ranging from [[linguistics]] to [[logic]]. The most common application of recursion is in [[mathematics]] and [[computer science]], in which it refers to a method of defining [[function (mathematics)|functions]] in which the function being defined is applied within its own definition; specifically it is defining an infinite statement using finite components. The term is also used more generally to describe a process of repeating objects in a self-similar way.  

==Formal definitions of recursion==
[[File:Screenshot Recursion via vlc.png|thumb|Recursion in a screen recording program, where the smaller window contains a snapshot of the entire screen.]]
In [[mathematics]] and [[computer science]], a class of objects or methods exhibit recursive behavior when they can be defined by two properties:

# A simple base case (or cases), and
# A set of rules which reduce all other cases toward the base case.

For example, the following is a recursive definition of a person's ancestors:
*One's [[parent]]s are one's [[ancestor]]s (''base case'').
*The parents of one's ancestors are also one's ancestors (''recursion step'').

The [[Fibonacci sequence]] is a classic example of recursion:

* Fib(0) is 0 [base case]
* Fib(1) is 1 [base case]
* For all integers n > 1: Fib(n) is (Fib(n-1) + Fib(n-2)) [recursive definition]

A convenient mental model of recursion defines the recursive object (whether that object is an equation, an algorithm, an image, or a rule) in terms of "previously defined" objects of the same class. For example: How do you move a stack of 100 boxes? Answer: you move one box, remember where you put it, and then solve the smaller problem: how do you move a stack of 99 boxes? Eventually, you're left with the problem of how to move a single box, which you know how to do.

Many mathematical axioms are based upon recursive rules. For example, the formal definition of the [[natural number]]s in [[set theory]] follows: 1 is a natural number, and each natural number has a successor, which is also a natural number. By this base case and recursive rule, one can generate the set of all natural numbers

A more humorous illustration goes: ''"To understand recursion, you must first understand recursion."'' Or perhaps more accurate is the following, from [[Andrew Plotkin]]: ''"If you already know what recursion is, just remember the answer. Otherwise, find someone who is standing closer to [[Douglas Hofstadter]] than you are; then ask him or her what recursion is."''

Recursively defined mathematical objects include [[function (mathematics)|function]]s, [[set (mathematics)|sets]], and especially [[fractal]]s.

==Recursion in language==
Linguist [[Noam Chomsky]] theorizes that unlimited extension of a language such as [[English language|English]] is possible using the recursive device of embedding phrases within sentences. Thus, a chatty person may say, ''"Dorothy, who met the wicked Witch of the West in Munchkin Land where her wicked Witch sister was killed, liquidated her with a pail of water."'' Clearly, two simple sentences—''"Dorothy met the Wicked Witch of the West in Munchkin Land"'' and ''"Her sister was killed in Munchkin Land"''—can be embedded in a third sentence, ''"Dorothy liquidated her with a pail of water,"'' to obtain a very verbose sentence.

The idea that recursion is an essential property of human language (as Chomsky suggests) is challenged by [[linguistics|linguist]] [[Daniel Everett]] in his work ''Cultural Constraints on Grammar and Cognition in Pirahã: Another Look at the Design Features of Human Language'', in which he hypothesizes that cultural factors made recursion unnecessary in the development of the [[Pirahã language]]. This concept, which challenges Chomsky's idea that recursion is the only trait which differentiates human and animal communication, is currently under debate.
Nevins, Andrew and David Pesetsky and Cilene Rodrigues provide a debate against this proposal in Evidence and Argumentation: A Reply to Everett (2009). Language 85.3: 671--681 (2009). Indirect proof that Everett's idea are wrong come from works in neurolinguistics where it appears that all human being are endowed with the very same neurobiological structures to manage with all and only recursive langauages. For a review, see Kaan et al. (2002)

Recursion in linguistics enables '[[discrete infinity]]' by embedding phrases within phrases of the same type in a hierarchical structure. Without recursion, language does not have 'discrete infinity' and cannot embed sentences into infinity (with a '[[Matryoshka doll|Russian nesting doll]]' effect). Everett contests that language must have discrete infinity, and that the Pirahã language - which he claims lacks recursion - is in fact finite. He likens it to the finite game of [[chess]], which has a finite number of moves but is nevertheless very productive, with novel moves being discovered throughout history.

===Recursion in plain English===
Recursion is the process a procedure goes through when one of the steps of the procedure involves rerunning the procedure. A procedure that goes through recursion is said to be 'recursive'.  conversely, a product that is the result of a recursive procedure is said to be recursive.

To understand recursion, one must recognize the distinction between a procedure and the running of a procedure. A procedure is a set of steps that are to be taken based on a set of rules. The running of a procedure involves actually following the rules and performing the steps. An analogy might be that a procedure is like a cookbook in that it is the possible steps, while running a procedure is actually preparing the meal.

A procedure is recursive if one of the steps that makes up the procedure calls for a new instance of that procedure; a recursive four-course meal would be a meal in which one of the choices of appetizer, salad, entrée, or dessert was an entire meal unto itself. So a recursive meal might be potato skins, baby greens salad, chicken Parmesan, and for dessert, a four-course meal, consisting of crab cakes, Caesar salad, for an entrée, a four-course meal, and chocolate cake for dessert, so on until each of the meals within the meals is completed.

<!--
A recursive procedure must complete every one of its steps.  Even if a new running is called in one of its steps, each running must run through the remaining steps. What this means in reference to the analogy of the menu is that even if the salad is an entire four-course meal unto itself, you still have to eat your entrée and dessert.

Comment: Routines can be written in programs such that they are recursive until a certain condition is satisfied, and then they continue with other code.  Jehan60188, Jan, 2011
-->

===Recursive humor===

A common joke is the following "definition" of recursion.<ref>{{cite web|url=http://catb.org/~esr/jargon/html/R/recursion.html |title=recursion |publisher=Catb.org |date= |accessdate=2010-04-07}}</ref>

:'''Recursion'''
::See "Recursion".

A variation on this joke is:

: '''Recursion'''
:: If you still don't get it, see: "Recursion".

which actually ''does'' terminate, as soon as the reader "gets it".

Another example occurs in an index entry on page 269 of Kernighan and Ritchie's book "[[The C Programming Language (book)|The C Programming Language]]":

::''recursion    86, 139, 141, 182, 202, 269''

Other examples are [[recursive acronym]]s, such as [[GNU]], [[PHP]], [[YAML]], [[HURD]] or [[Wine_(software)|WINE]].

==Recursion in mathematics==
[[Image:Sierpinski Triangle.svg|right|thumb|250px|A [[Sierpinski triangle]]—a confined recursion of triangles to form a geometric [[lattice (group)|lattice]].]]
===Recursively defined sets===
{{Main|Recursive definition}}

====Example: the natural numbers====
The canonical example of a recursively defined set is given by the [[natural numbers]]:

:1 is in <math>\mathbb{N}</math>
:if ''n'' is in <math>\mathbb{N}</math>, then ''n'' + 1 is in <math>\mathbb{N}</math>
:The set of natural numbers is the smallest set of real numbers satisfying the previous two properties.



====Example: The set of true reachable propositions====
Another interesting example is the set of all true "reachable" propositions in an [[axiomatic system]].

*if a proposition is an axiom, it is a true reachable proposition.
*if a proposition can be obtained from true reachable propositions by means of inference rules, it is a true reachable proposition.
*The set of true reachable propositions is the smallest set of reachable propositions satisfying these conditions.

This set is called 'true reachable propositions' because: in non-constructive approaches to the foundations of mathematics, the set of true propositions is larger than the set recursively constructed from the axioms and rules of inference. See also [[Gödel's incompleteness theorems]].

(Note that determining whether a certain object is in a recursively defined set is not an algorithmic task.)

===Functional recursion===
A [[function (mathematics)|function]] may be partly defined in terms of itself.  A familiar example is the [[Fibonacci number]] sequence: ''F''(''n'') = ''F''(''n'' &minus; 1) + ''F''(''n'' &minus; 2).  For such a definition to be useful, it must lead to values which are non-recursively defined, in this case ''F''(0) = 0 and ''F''(1) = 1.

A famous recursive function is the [[Ackermann function]] which, unlike the Fibonacci sequence, cannot be expressed without recursion.

===Recursive proofs===
Applying the standard technique of [[proof by cases]] to recursively-defined sets or functions as in the preceding sections yields [[structural induction]], a powerful generalization of [[mathematical induction]] which is widely used to derive proofs in [[mathematical logic]] and [[computer science]].

For instance, the standard way to define new systems of mathematics or logic is to define objects (such as "true" and "false", or "all natural numbers"), then define operations on these.  These are the base cases.  After this, all valid computations in the system are defined with rules for assembling these.  In this way, if the base cases and rules are all proven to be calculable, then any formula in the mathematical system will also be calculable.

While the above example may seem unexciting, this type of proof is the normal way to prove that a calculation is impossible.  This can often save a lot of time.  For example, this type of proof was used to prove that the area of a circle is not a simple ratio of its diameter, and that [[angle trisection|no angle can be trisected]] with compass and straightedge—both puzzles that fascinated the ancients.

===Recursive optimization===
[[Dynamic programming]] is an approach to [[optimization (mathematics)|optimization]] which restates a multiperiod or multistep optimization problem in recursive form. The key result in dynamic programming is the [[Bellman equation]],
which writes the value of the optimization problem at an earlier time (or earlier step)
in terms of its value at a later time (or later step).

==Recursion in computer science==
[[File:Web Page.png|thumb|alt=|This screenshot of a web page includes the screen shot itself.]]
{{Main|Recursion (computer science)}}
A common method of simplification is to divide a problem into subproblems of the same type. As a [[computer programming]] technique, this is called [[divide and conquer algorithm|divide and conquer]] and is key to the design of many important algorithms. Divide and conquer serves as a top-down approach to problem solving, where problems are solved by solving smaller and smaller instances. A contrary approach is [[dynamic programming]]. This approach serves as a bottom-up approach, where problems are solved by solving larger and larger instances, until the desired size is reached.

A classic example of recursion is the definition of the [[factorial]] function, given here in C code:

 <source lang="c">
 unsigned int factorial(unsigned int n) 
 {
     if (n <= 1) 
         return 1;
     else
         return n * factorial(n-1);
 }
 </source>

The function calls itself recursively on a smaller version of the input (n - 1) and multiplies the result of the recursive call by n, until reaching the [[base case]], analogously to the mathematical definition of factorial.

Recursion in computer programming is exemplified when a function is defined in terms of simpler, often smaller versions of itself. The solution to the problem is then devised by combining the solutions obtained from the simpler versions of the problem. One example application of recursion is in [[parser]]s for programming languages. The great advantage of recursion is that an infinite set of possible sentences, designs or other data can be defined, parsed or produced by a finite computer program.

[[Recurrence relation]]s are equations to define one or more sequences  recursively. Some specific kinds of recurrence relation can be "solved" to obtain a non-recursive definition.

Use of recursion in an algorithm has both advantages and disadvantages.  The main advantage is usually simplicity.  The main disadvantage is often that the algorithm may require large amounts of memory if the depth of the recursion is very large.

==The recursion theorem==
In [[set theory]], this is a theorem guaranteeing that recursively defined functions exist.  Given a set ''X'', an element ''a'' of ''X'' and a function <math>f: X \rightarrow X</math>, the theorem states that there is a unique function <math>F: \mathbb{N} \rightarrow X</math> (where <math>\mathbb{N}</math> denotes the set of natural numbers including zero) such that
:<math>F(0) = a</math>
:<math>F(n + 1) = f(F(n))</math>
for any natural number ''n''.

===Proof of uniqueness===
Take two functions <math>F: \mathbb{N} \rightarrow X</math>  and <math>G: \mathbb{N} \rightarrow X</math>  such that:

:<math>F(0) = a</math>
:<math>G(0) = a</math>
:<math>F(n + 1) = f(F(n))</math>
:<math>G(n + 1) = f(G(n))</math>

where ''a'' is an element of ''X''.

It can be proved by [[mathematical induction]] that <math>F(n) = G(n)</math> for all natural numbers ''n'':

:'''Base Case''': <math>F(0) = a = G(0)</math> so the equality holds for <math>n = 0</math>.

:'''Inductive Step''': Suppose <math>F(k) = G(k)</math> for some <math>k \in \mathbb{N}</math>. Then <math>F(k+1) = f(F(k)) = f(G(k)) = G(k+1).</math>
::Hence F(k) = G(k) implies F(k+1) = G(k+1).

By Induction, <math>F(n) = G(n)</math> for all <math>n \in \mathbb{N}</math>.
===Examples===

Some common recurrence relations are:
{{col-begin}}
{{col-break}}
*[[Factorial]]: <math>n! = n (n - 1)! = n (n - 1)\cdots 1</math>
*[[Fibonacci numbers]]: <math>f (n) = f (n - 1) + f (n - 2)</math>
*[[Catalan number]]s: <math>C_0=1</math>, <math>C_{n+1} = (4n+2)C_n/(n+2)</math>
*Computing compound [[interest]]
*The [[Tower of Hanoi]]
*[[Ackermann function]]
*[[Population growth rate]]
*Odds of a [[birthday problem|shared birthday]] among a group of people.
{{col-end}}

==See also==
<div style="-moz-column-count:4; column-count:4;">
* [[Church-Turing thesis]]
* [[Continuous predicate]]
* [[Corecursion]]
* [[Course-of-values recursion]]
* [[Fixed point combinator]]
* [[Infinite loop]]
* [[Infinitism]]
* [[Iterated function]]
* [[Mise en abyme]]
* [[Primitive recursive function]]
<!--
  Your radical ideas about adding [[Recursion]] have
  already occurred to other people and been removed by 
  people with no sense of humor..  See the subsection
  "Recursive humor" for details.
-->
* [[Reentrant (subroutine)]]
* [[Self-reference]]
* [[Strange loop]]
* [[Tail recursion]]
* [[Turtles all the way down]]
* [[Viable System Model]]
</div>

==References==
<references/>

==External links==
{{Wiktionary|recursion|recursivity}}
*{{cite book | author=Johnsonbaugh, Richard | title=Discrete Mathematics | publisher=Prentice Hall | year=2004 | isbn=0-13-117686-2 }}
*{{cite book | author=Hofstadter, Douglas | title=Gödel, Escher, Bach: an Eternal Golden Braid | publisher=Basic Books | year=1999 | isbn=0-465-02656-7 }}
*{{cite book | author=Shoenfield, Joseph R. | title=Recursion Theory | publisher=A K Peters Ltd | year=2000 | isbn=1-56881-149-7 }}
*{{cite book | author=Causey, Robert L. | title=Logic, Sets, and Recursion | publisher=Jones & Bartlett | year=2001 | isbn=0-7637-1695-2 }}
*{{cite book | author=Cori, Rene; Lascar, Daniel; Pelletier, Donald H. | title=Recursion Theory, Godel's Theorems, Set Theory, Model Theory | publisher=Oxford University Press | year=2001 | isbn=0-19-850050-5 }}
*{{cite book | author=Barwise, Jon; Moss, Lawrence S. | title=Vicious Circles | publisher=Stanford Univ Center for the Study of Language and Information | year=1996 | isbn=0-19-850050-5 }}  - offers a treatment of [[corecursion]].
*{{cite book | author=Rosen, Kenneth H. | title=Discrete Mathematics and Its Applications | publisher=McGraw-Hill College | year=2002 | isbn=0-07-293033-0 }}
*{{cite book | author=Cormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, Clifford Stein | title=Introduction to Algorithms | publisher=Mit Pr | year=2001 | isbn=0-262-03293-7 }}
*{{cite book | author = Kernighan, B.; Ritchie, D. |  title=The C programming Language | publisher=Prentice Hall | year = 1988 | isbn = 0-13-110362-8 }}
*{{cite book | author=Stokey, Nancy,; Robert Lucas; Edward Prescott | title=Recursive Methods in Economic Dynamics | publisher=Harvard University Press | year=1989 | isbn=0674750969}}
*{{cite book | author=Hungerford; title=Algebra | publisher=Springer|year=1980|isbn=978-0387905181}}, first chapter on set theory.
* [http://www.freenetpages.co.uk/hp/alan.gauld/tutrecur.htm Recursion] - tutorial by Alan Gauld
* [http://amitksaha.files.wordpress.com/2009/05/recursion-primer.pdf A Primer on Recursion]- contains pointers to recursion in Formal Languages, Linguistics, Math and Computer Science
* [http://research.swtch.com/2010/03/zip-files-all-way-down.html Zip Files All The Way Down]
*[http://www.ucl.ac.uk/psychlangsci/staff/linguistics-staff/nevins-publications/npr09b Nevins, Andrew and David Pesetsky and Cilene Rodrigues. Evidence and Argumentation: A Reply to Everett (2009). Language 85.3: 671--681 (2009)]
*[http://faculty.washington.edu/losterho/kaan_and_swaab.pdf Kaan, E. – Swaab, T. Y. (2002) “The brain circuitry of syntactic comprehension”,  Trends in Cognitive Sciences, vol. 6, Issue 8, 350-356.]

{{logic}}

[[Category:Mathematical logic]]
[[Category:Theory of computation]]
[[Category:Programming idioms]]
[[Category:Recursion]]
[[Category:Self-reference]]

[[ar:استدعاء ذاتي]]
[[bg:Рекурсия]]
[[ca:Recursivitat]]
[[cs:Rekurze]]
[[da:Rekursiv]]
[[de:Rekursion]]
[[el:Αναδρομή]]
[[es:Recursión]]
[[eo:Rikuro]]
[[fr:Récursivité]]
[[hi:पुनरावर्तन]]
[[hr:Rekurzija]]
[[io:Rekurso]]
[[id:Rekursi]]
[[is:Endurkvæmt fall]]
[[it:Algoritmo ricorsivo]]
[[he:רקורסיה]]
[[lt:Rekursija]]
[[hu:Rekurzió]]
[[nl:Recursie]]
[[ja:再帰]]
[[no:Rekursjon]]
[[pl:Rekurencja]]
[[pt:Recursividade]]
[[ro:Recursivitate]]
[[ru:Рекурсия]]
[[sa:पुनर्गमनवाद]]
[[simple:Recursion]]
[[sl:Rekurzija]]
[[sr:Рекурзија]]
[[fi:Rekursio]]
[[sv:Rekursion]]
[[ta:சுழல்]]
[[th:การเรียกซ้ำ]]
[[tg:Рекурсия]]
[[tr:Özyineleme]]
[[uk:Рекурсія]]
[[ur:Recursion]]
[[vi:Đệ quy]]
[[zh:递归]]</body> </html>