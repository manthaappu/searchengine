<html> <head> <title>Software evolution</title></head><body>{{Refimprove|date=October 2009}}

'''Software evolution''' is the term used in [[software engineering]] (specifically [[software maintenance]]) to refer to the process of developing [[software]] initially, then repeatedly updating it for various reasons.

==General introduction==

[[Fred Brooks]], in his key book ''[[The Mythical Man-Month]]'',<ref>[[Fred Brooks]], ''[[The Mythical Man-Month]]''. [[Addison-Wesley]], 1975 & 1995. ISBN
0-201-00650-2 & ISBN 0-201-83595-9.</ref> states that over 90% of the costs of a typical system arise in the maintenance phase, and that any successful piece of software will inevitably be maintained.

In fact, [[Agile methods]] stem from maintenance like activities in and around web based technologies, where the bulk of the capability comes from frameworks and standards.{{Citation needed|date=October 2009}}

Software maintenance address bug fixes and minor enhancements and software evolution focus on [[Adaptation (computer science)|adaptation]] and [[System migration|migration]].

==Types of software maintenance==

E.B. Swanson initially identified three categories of maintenance: corrective, adaptive, and perfective. Four categories of software were then catalogued by Lientz and Swanson (1980) <ref>Lientz, B.P. and Swanson, E.B., ''Software Maintenance Management, A Study Of The Maintenance Of Computer Application Software In 487 Data Processing Organizations''. Addison-Wesley, Reading MA, 1980. ISBN 0201042053</ref>.
These have since been updated and normalized internationally in the [[ISO/IEC]] 14764:2006:<ref>[[ISO/IEC]] 14764:2006, 2006.</ref>

* ''Corrective maintenance'': Reactive modification of a software product performed after delivery to correct discovered problems;
* ''Adaptive maintenance'': Modification of a software product performed after delivery to keep a software product usable in a changed or changing environment;
* ''Perfective maintenance'': Modification of a software product after delivery to improve performance or maintainability;
* ''Preventive maintenance'': Modification of a software product after delivery to detect and correct latent faults in the software product before they become effective faults.

All of the preceding take place when there is a known requirement for change.

Although these categories were supplemented by many authors like Warren et al. (1999){{Citation needed|date=October 2009}} and  Chapin (2001){{Citation needed|date=October 2009}}, the ISO/IEC 14764:2006 international standard has kept the basic four categories.

More recently the description of software maintenance and evolution has been done using ontologies (Kitchemham et al. (1999),{{Citation needed|date=October 2009}} Derider (2002),{{Citation needed|date=October 2009}} Vizca√≠no 2003,{{Citation needed|date=October 2009}} Dias (2003),{{Citation needed|date=October 2009}} and Ruiz (2004)),{{Citation needed|date=October 2009}} which enrich the description of the many evolution activities.

==Lehman's Laws of Software Evolution==
Prof. [[Meir M. Lehman]], who worked at [[Imperial College London]] from 1972 to 2002, and his colleagues have identified a set of behaviours in the evolution of proprietary software. These behaviours (or observations) are known as [[Lehman's laws of software evolution|''Lehman's Laws'']], and there are eight of them:

# Continuing Change
# Increasing Complexity
# Large Program Evolution
# Invariant Work-Rate
# Conservation of Familiarity
# Continuing Growth
# Declining Quality
# Feedback System

It is worth mentioning that the laws are believed to apply mainly to monolithic, proprietary software. For example, some empirical observations coming from the study of [[open source software development]] appear to challenge some of the laws {{Vague|date=June 2010}}{{Citation needed|date=June 2010}}.

The laws predict that change is inevitable and not a consequence of bad programming and that there are limits to what a software evolution team can achieve in terms of safely implementing changes and new functionality.

Maturity Models specific to software evolution have been developed to help improve processes to ensure continuous rejuvenation of the software evolves iteratively.

The "global process" that is made by the many stakeholders (e.g. developers, users, their managers) has many feedback loops. The evolution speed is a function of the feedback loop structure and other characteristics of the global system. Process simulation techniques, such as [[system dynamics]] can be useful in understanding and managing such global process.

Software evolution is not likely to be [[Darwinian evolution|Darwinian]], [[Lamarckian evolution|Lamarckian]] or [[Baldwinian evolution|Baldwinian]], but an important phenomenon on its own. Giving the increasing dependence on software at all levels of society and economy, the successful evolution of software is becoming increasingly critical. This is an important topic of research that hasn't received much attention.

The evolution of software, because of its rapid path in comparison to other man-made entities, was seen by Lehman as the "fruit fly" of the study of the evolution of artificial systems.

==See also==
* [[Software entropy]]

* [[Meir M. Lehman]]
* [[Darwinian evolution]]
* [[Lamarckian evolution]]
* [[Baldwinian evolution]]

* ''[[Journal of Software Maintenance and Evolution: Research and Practice]]''

==References==
{{Reflist}}

[[Category:Software engineering]]
[[Category:Software maintenance]]

[[de:Software-Evolution]]</body> </html>