<html> <head> <title>Component-based software engineering</title></head><body>{{Cleanup-rewrite|date=September 2009}}
{{Merge to|modular programming|discuss=Talk:object (computer science)#Merge section into modular programming|date=September 2009}}<!-- this article should be merged with modular programming which is what it is essentially about with perhaps a redirection from component-based_software engineering -->

[[Image:Component-based Software Engineering (CBSE) - example 1.svg|thumb|0|A simple example of two components expressed in [[Unified Modeling Language|UML]] 2.0. The checkout component, responsible for facilitating the customer's order, ''requires'' the card processing component to charge the customer's credit/debit card (functionality which the latter ''provides'').]]
{{Programming paradigms}}

'''Component-based software engineering (CBSE)''' (also known as '''component-based development (CBD)''') is a branch of [[software engineering]] which emphasizes the [[separation of concerns]] in respect of the wide-ranging functionality available throughout a given software system. This practice aims to bring about an equally wide-ranging degree of benefits in both the short-term and the long-term for the software itself and for organizations that sponsor such software.

Software engineers regard components as part of the starting platform for [[service-orientation]]. Components play this role, for example, in [[Web Services]], and more recently, in [[Service-oriented architecture|Service-Oriented Architecture (SOA)]] - whereby a component is converted{{By whom|date=February 2010}} into a ''service'' and subsequently inherits further characteristics beyond that of an ordinary component.

Components can produce events or consume events and can be used for [[event driven architecture]] (EDA).

== Definition and characteristics of components ==
An individual component is a software package, a [[web service]], or a [[Modular programming|module]] that encapsulates a set of related functions (or data).

All system processes are placed into separate components so that all of the data and functions inside each component are semantically related (just as with the contents of classes). Because of this principle, it is often said that components are ''modular'' and ''cohesive''.

With regard to system-wide co-ordination, components communicate with each other via ''interfaces''. When a component offers services to the rest of the system, it adopts a ''provided'' interface which specifies the services that other components can utilize, and how they can do so. This interface can be seen as a signature of the component - the client does not need to know about the inner workings of the component (implementation) in order to make use of it. This principle results in components referred to as ''encapsulated''. The [[Unified Modeling Language|UML]] illustrations within this article represent provided interfaces by a lollipop-symbol attached to the outer edge of the component.

However when a component needs to use another component in order to function, it adopts a ''used'' interface which specifies the services that it needs. In the UML illustrations in this article, ''used interfaces'' are represented by an open socket symbol attached to the outer edge of the component.

[[Image:Component-based Software Engineering (CBSE) - example 2.gif|thumb|350px|left|A simple example of several software components - pictured within a hypothetical holiday-reservation system represented in [[Unified Modeling Language|UML]] 2.0.]]

Another important attribute of components is that they are ''substitutable'', so that a component can replace another (at design time or run-time), if the successor component meets the requirements of the initial component (expressed via the interfaces). Consequently, components can be replaced with either an updated version or an alternative without breaking the system in which the component operates.

As a general rule of thumb for engineers substituting components, component B can immediately replace component A if component B provides at least what component A provided, and uses no more than what component A used.

Software components often take the form of [[object (computing)|objects]] (not [[Class (computer science)|classes]]) or collections of objects (from [[object-oriented programming]]), in some binary or textual form, adhering to some [[interface description language]] (IDL) so that the component may exist autonomously from other components in a [[computer]].

When a component is to be accessed or shared across execution contexts or network links, techniques such as [[serialization]] or [[marshalling (computer science)|marshalling]] are often employed to deliver the component to its destination.

[[Reusability]] is an important characteristic of a high-quality software component. Programmers should design and implement  software components in such a way that many different programs can reuse them. Furthermore, [[Component-Based Usability Testing|component-based usability testing]] should be considered when software components directly interact with users.

It takes significant effort and awareness to write a software component that is effectively reusable. The component needs to be:

* fully documented
* thoroughly tested
** robust - with comprehensive input-validity checking
** able to pass back appropriate [[error message]]s or return codes
* designed with an awareness that it ''will'' be put to unforeseen uses

In the 1960s, programmers built scientific [[subroutine]] libraries that were reusable in a broad array of engineering and scientific applications. Though these subroutine libraries reused well-defined [[algorithms]] in an effective manner, they had a limited domain of application. Commercial sites routinely created application programs from reusable modules written in [[Assembly language|Assembler]], [[COBOL]], [[PL/1]] and other [[second generation language|second-]] and [[third generation language|third-generation languages]] using both [[operating system|System]] and user application libraries.

{{As of | 2010}}, modern reusable components encapsulate both data structures and the algorithms that are applied to the data structures.
It{{Clarify|date=February 2010}} builds on prior theories of [[object (object-oriented programming)|software objects]], [[software architecture]]s, [[software framework]]s and [[software design pattern]]s, and the extensive theory of [[object-oriented programming]] and the [[object oriented design]] of all these. It claims that software components, like the idea of hardware [[electronic component|components]], used for example in telecommunications, can ultimately be made interchangeable and reliable. On the other hand, it is argued that it is a mistake to focus on independent components rather than the framework (without which they would not exist).<ref>
[http://existentialprogramming.blogspot.com/search/label/components "There is no such thing as a Component", Bruce Wallace, Existential Programming, June, 2000]</ref>

==History==
<!-- Commented out because image was deleted: [[Image:Software components lecture large.jpg|thumb|left|250px|Douglas McIlroy's historic lecture on software components at the NATO conference in Garmisch, Germany (1968). {{deletable image-caption}}]] -->

The idea that [[software]] should be componentized - built from prefabricated ''components'' - first became prominent with [[Douglas McIlroy]]'s address at the [[NATO]] conference on [[software engineering]] in [[Garmisch-Partenkirchen|Garmisch]], [[Germany]], 1968,<!-- The practice of modular programming existed before 1968 I am certain --> titled ''Mass Produced Software Components''. The conference set out to counter the so-called [[software crisis]]. McIlroy's subsequent inclusion of [[pipes and filters]] into the [[Unix]] [[operating system]] was the first implementation of an infrastructure for this idea.

[[Brad Cox]] of [[Stepstone]] largely defined the modern concept of a software component{{Citation needed|date=February 2010}}. He called them ''Software ICs'' and set out to create an infrastructure and market for these components by inventing the [[Objective-C]] programming language. (He summarizes this view in his book ''Object-Oriented Programming - An Evolutionary Approach'' 1986.)

[[IBM]] led the path{{Citation needed|date=February 2010}} with their [[System Object Model|System Object Model (SOM)]] in the early 1990s.<!-- IBM built System/360 operating systems and language compilers from many component modules, both binary and source both statically linked and dynamically loaded--> Some{{Who|date=February 2010}} claim that [[Microsoft]] paved the way for actual deployment of component software with [[Object linking and embedding|OLE]] and [[Component Object Model|COM]]. {{As of | 2010}} many successful software component models exist.

==Differences from object-oriented programming==
Proponents of [[object-oriented programming]] (OOP) maintain that software should be written according to a mental model of the actual or imagined objects it represents. OOP and the related disciplines of [[object-oriented design]] and [[object-oriented analysis]] focus on modeling real-world{{Citation needed|date=January 2009}} interactions and attempting to create "verbs" and "nouns" which can be used in more human-readable ways, ideally by end users as well as by programmers coding for those end users.

Component-based software engineering, by contrast, makes no such assumptions, and instead states that developers should construct software by gluing together prefabricated components - much like in the fields of [[electronics]] or [[mechanics]]. Some peers{{Who|date=January 2009}} will even talk of modularizing systems as software components as a new [[programming paradigm]].

Some{{Who|date=October 2009}} argue that earlier [[computer scientist]]s made this distinction, with [[Donald Knuth]]'s theory of "[[literate programming]]" optimistically assuming there was convergence between intuitive and formal models, and [[Edsger Dijkstra]]'s theory in the article ''[[The Cruelty of Really Teaching Computer Science]]'', which stated that programming was simply, and only, a branch of [[mathematics]].{{Citation needed|date=October 2009}}

In both forms, this notion has led to many academic debates{{Weasel-inline|date=October 2009}} about the pros and cons of the two approaches and possible strategies for uniting the two. Some{{Who|date=October 2009}} consider the different strategies not as competitors, but as descriptions of the same problem from different points of view.{{Citation needed|date=October 2009}}

==Architecture==
<!-- What about simple programs composed of modules for starters? etc etc. Why jump to servers as examples of module use?-->
A computer running several software components is often called an [[application server]]. Using this combination of application servers and software components is usually called [[distributed computing]]. The usual real-world application of this is in e.g. financial applications or business software.

==Technologies==
* [[Pipeline (software)|Pipes and Filters]]
** [[Unix]] [[operating system]]
* Component-oriented programming
** [[SOFA component system]] [http://sofa.ow2.org] from [http://www.objectweb.org ObjectWeb]
** [[Fractal component model]] [http://fractal.ow2.org/] from [http://www.objectweb.org ObjectWeb]
** [[rCOS]] method of component-based model driven design [http://rcos.iist.unu.edu] from [http://www.iist.unu.edu UNU-IIST]
** [[Visual Basic Extension]]s, [[Component Object Model|OCX/ActiveX/COM]] and [[Distributed Component Object Model|DCOM]] from [[Microsoft]]
** [[XPCOM]] from [[Mozilla Foundation]]
** [[Visual Component Library|VCL]] and [[Component Library for Cross Platform|CLX]] from [[Borland]] and similar free [[Lazarus (software)|LCL]] library.
** [[Enterprise JavaBeans]] from [[Sun Microsystems]] (now [[Oracle_Corporation|Oracle]])
** [[Universal Network Objects|UNO]] from the [[OpenOffice.org]] office suite
** [[Eiffel (programming language)|Eiffel programming language]]
** [[Oberon programming language|Oberon]], [[Component Pascal]], and [[BlackBox Component Builder]]
** Bundles as defined by the [[Osgi|OSGi]] Service Platform
** The <code>System.ComponentModel</code> namespace in [[Microsoft .NET]]
** [[Flow-based programming]]
** [[MidCOM]] [http://www.midgard-project.org/documentation/midcom/] component framework for [[Midgard (software)|Midgard]] and [[PHP]]
** [[Common Component Architecture]] (CCA) - Common Component Architecture Forum [http://www.cca-forum.org/wiki], Scientific/HPC Component Software
*** TASCS [http://tascs-scidac.org/] - SciDAC [http://www.scidac.gov/] Center for Technology for Advanced Scientific Component Software
* Component-based [[software framework]]s for specific domains
** Earth System Modeling Framework ([[ESMF]])
* [[Compound document]] technologies
** Active Documents in [[Oberon (operating system)|Oberon System]] and [[BlackBox Component Builder]]
** [[Bonobo (component model)]], a part of [[GNOME]]
** [[KPart]], the [[KDE]] Compound document technology
** [[Object linking and embedding]] (OLE)
** [[OpenDoc]]
** [[Fresco (computing)|Fresco]]
* [[Business object (computer science)|Business object]] technologies
** [[Newi]]
* [[Distributed computing]] software components
** [[9P]] distributed protocol developed for [[Plan 9 from Bell Labs|Plan 9]], and used by [[Inferno (operating system)|Inferno]] and other systems.
** [[CORBA]] and the [[CORBA Component Model]] from the [[Object Management Group]]
** [[D-BUS]] from the [[freedesktop.org]] organization
** [[Distributed Component Object Model|DCOM]] and later versions of [[Component object model|COM]] (and COM+) from [[Microsoft]]
** [[DCOP]] from [[KDE]]
** DSOM and [[System Object Model|SOM]] from [[International Business Machines|IBM]] (now scrapped)
** [[Internet Communications Engine|ICE]] from [[ZeroC]]
** [[Java EE]] from [[Sun Microsystems|Sun]]
** [[.NET Remoting]] from [[Microsoft]]
** [[Web Service]]s
*** [[Representational State Transfer|REST]]
** [[Universal Network Objects]] (UNO) from [[OpenOffice.org]]
** [[Zope]] from [http://www.zope.com Zope Corporation]
* Interface description languages
** [[XML-RPC]], the predecessor of SOAP
** [[Simple Object Access Protocol|SOAP]] [[Interface description language|IDL]] from [[W3C]]
** [[WDDX]]
** Part of both [[Component object model|COM]] and [[CORBA]]
** [[Open Service Interface Definitions]]
** [[Platform-Independent Component Modeling Language]]
** SIDL [https://computation.llnl.gov/casc/components/components.html] - Scientific Interface Definition Language
*** Part of the [[Babel Middleware|Babel]] [https://computation.llnl.gov/casc/components/babel.html] Scientific Programming Language Interoperability System
*** (SIDL and Babel are core technologies of the CCA [http://www.cca-forum.org/wiki] and the SciDAC [http://www.scidac.gov/] TASCS [http://tascs-scidac.org/] Center - see above.)
* [[Generic programming]] emphasizes separation of algorithms from data representation
* [http://www.pocomatic.com/docs/whitepapers/ioc Inversion of Control (IoC) and Plain Old C++/Java Object (POCO/POJO) component frameworks]

==See also==
* [[Business logic]]
* [[Modular programming]]
* [[Third party software component]]
* [[Web Service]]

==References==
{{Reflist}}
{{Refimprove|date=December 2008}}

==Further reading==
* Brad J. Cox, Andrew J. Novobilski (1991). ''Object-Oriented Programming: An Evolutionary Approach''. 2nd ed. Addison-Wesley, Reading ISBN 0-201-54834-8
* Bertrand Meyer (1997). ''Object-Oriented Software Construction''. 2nd ed. Prentice Hall.
* George T. Heineman, William T. Councill (2001). ''Component-Based Software Engineering: Putting the Pieces Together''. Addison-Wesley Professional, Reading 2001 ISBN 0-201-70485-4
* [[Richard Veryard]] (2001). ''Component-based business : plug and play''. London : Springer. ISBN 1852333618
* Clemens Szyperski (2002). ''Component Software: Beyond Object-Oriented Programming''. 2nd ed. Addison-Wesley Professional, Boston ISBN 0-201-74572-0
* David Polberger (2009). ''Component technology in an embedded system''. Master's thesis in computer science, [http://www.polberger.se/components/ available online]. ISSN 1651-6389

==External links==
{{External links|date=September 2009}}
* [http://www.cs.dartmouth.edu/~doug/components.txt ''Mass Produced Software Components'' by M. Douglas McIlroy]
* [http://homepages.cs.ncl.ac.uk/brian.randell/NATO/ NATO Science Committee Software Engineering Conference in Garmisch] – reports (PDF)
* [http://virtualschool.edu/cox/pub/PSIR ''Planning the Software Industrial Revolution''] The history of manufacturing vs software compared.
* [http://distributed-software.blogspot.com/2006/06/independence-of-component-oriented.html ''The independence of notion of component-orientation''].
* [http://virtualschool.edu/mybank ''Cox's feasibility demonstration''] of a usage-based mechanism for incentivizing component producers.
* comprehensive list of [http://xplc.sourceforge.net/doc/others.php Component Systems]
* Article "[http://www.dre.vanderbilt.edu/~schmidt/reuse-lessons.html Why Software Reuse has Failed and How to Make It Work for You]" by [[Douglas C. Schmidt]]
* [http://www.cbsdf.com/ps_blog/Component-characteristics.htm New proposals to explore the Component properties: (i) Reuse] and [http://www.cbsdf.com/ps_blog/SE-MissingLink.htm (ii) Replaceable]
* http://www.smb.uklinux.net/reusability/
* [http://www.dyscas.org Dynamically Self Configuring Automotive System]
* [http://www.cbsdf.com/misc_docs/Rules-CBE.htm New proposal for exploring a kind of CBSE comparable to the CBE]
* [http://existentialprogramming.blogspot.com/search/label/components "There is no such thing as a Component" essay]

{{DEFAULTSORT:Component-Based Software Engineering}}
[[Category:Object-oriented programming]]
[[Category:Software architecture]]
[[Category:Software components]]

[[de:Komponentenbasierte Entwicklung]]
[[es:Programación orientada a componentes]]
[[fa:مهندسی نرم افزار بر اساس مولفه]]
[[fr:Programmation orientée composant]]
[[gl:Compoñente de software]]
[[ja:ソフトウェアコンポーネント]]
[[pl:Komponent (informatyka)]]
[[pt:Engenharia de software baseada em componentes]]
[[ru:Компонентно-ориентированное программирование]]
[[uk:Компонентно-орієнтоване програмування]]
[[zh:基于组件的软件工程]]</body> </html>