<html> <head> <title>Cycles per instruction</title></head><body>{{Unreferenced stub|auto=yes|date=December 2009}}
In [[computer architecture]], '''cycles per instruction''' (aka '''clock cycles per instruction''', '''clocks per instruction''', or '''CPI''') is a term used to describe one aspect of a [[central processing unit|processor's]] performance: the number of [[clock cycle]]s that happen when an [[Instruction (computer science)|instruction]] is being executed.  It is the [[multiplicative inverse]] of [[instructions per cycle]].

==Explanation==
Let us assume a [[classic RISC pipeline]], with the following 5 stages:

# Instruction fetch cycle (IF)
# Instruction decode/Register fetch cycle (ID)
# Execution/Effective address cycle (EX)
# Memory access (MEM)
# Write-back cycle (WB)

Each stage requires one clock cycle and an instruction passes through the stages sequentially. Without [[pipelining]], a new instruction is fetched in stage 1 only after the previous instruction finishes at stage 5. Therefore without pipelining the number of cycles it takes to execute an instruction is 5. This is the definition of CPI.

With pipelining we can improve the CPI by exploiting [[instruction level parallelism]]. For example, what if an instruction is fetched every cycle? We could theoretically have 5 instructions in the 5 pipeline stages at once (one instruction per stage). In this case, a different instruction would complete stage 5 in every clock cycle, and therefore on average we have one clock cycle per instruction (CPI = 1).

With a single-issue processor, the best CPI attainable is 1. However with multiple-issue processors, we may achieve even better CPI values. For example a processor that issues two instructions per clock cycle (see [[Superscalar]]) can achieve a CPI of 0.5 when two instructions are completing every clock cycle.

==Calculations==
=== Multi-cycle example ===

For the multi-cycle [[MIPS architecture|MIPS]], there are 5 types of instructions:

* Load (5 cycles)
* Store (4 cycles)
* [[MIPS architecture#MIPS assembly language|R-type]] (4 cycles)
* [[MIPS architecture#MIPS assembly language|Branch]] (3 cycles)
* [[MIPS architecture#MIPS assembly language|Jump]] (3 cycles)

If a program has:

* 50% R-type instructions
* 15% load instructions
* 25% store instructions
* 8% branch instructions
* 2% jump instructions

then, the CPI is:

: CPI = (4 × 50  +  5 × 15  +  4 × 25  +  3 × 8  +  3 × 2) / 100 = 4.05.

==Example==
A 40-[[MHz]] processor was used to execute a [[benchmark program]] with the following instruction mix and [[clock cycle]] count:

{| class="wikitable"
|-
! Instruction type
! Instruction count 
! Clock cycle count
     
|-
| Integer arithmetic            
| 45000   
| 1
|-
| Data transfer  
| 32000
| 2
|-
| Floating point            
| 15000
| 2
|- 
| Control transfer
| 8000                   
| 2
|}

Determine the effective CPI, [[MIPS architecture|MIPS]] rate, and execution time for this program.

: Total instruction count = 100000.

: CPI = (45000*1 + 32000*2 + 15000*2 + 8000*2)/100000 = 155000/100000 = 1.55.

: MIPS = clock frequency/(CPI*1000000) = (40*1000000)/(1.55*1000000) = 25.8.

Therefore:

: Execution time (T) = CPI*Instruction count*clock time = CPI*Instruction count/frequency = 1.55*100000/40000000 = 1.55/400 = 3.87 ms.

==See also==
* [[Instructions per cycle]]
* [[Megahertz myth]]
* The [[Benchmark (computing)|benchmark]] article provides a useful introduction to computer performance measurement for those readers interested in the topic.

{{DEFAULTSORT:Cycles Per Instruction}}
[[Category:Instruction processing]]
[[Category:Clock signal]]


{{Microcompu-stub}}

[[it:Cicli Per Istruzione]]</body> </html>