<html> <head> <title>Language primitive</title></head><body>In computing, '''language primitives''' are the simplest elements available in a [[programming language]]. A primitive can be defined as the smallest 'unit of processing' available to a programmer of a particular machine, or can be an [[Atomic operation|atomic]] element of an [[Expression (programming)|expression]] in a language.

==Machine level primitives==
A [[machine instruction]], usually generated by an [[Assembler program]], is often considered the smallest unit of processing although this is not always the case. It typically performs what is perceived to be one single operation such as copying a [[byte]] or [[String (computer science)|string]] of bytes from one [[computer memory|memory]] location to another or adding one [[processor register]] to another.
==Micro code primitives==
Many of today's [[computer]]s, however, actually embody an even lower unit of processing known as [[microcode]] which interprets the "machine code" and it is then that the microcode instructions would be the ''genuine'' primitives. These instructions would typically be available for modification only by the [[computer hardware|hardware]] vendors programmers.
==High level language primitives==
A [[high-level programming language]] (''HLL'') program is composed of discrete [[statements]] and [[primitive data type]]s that may also be ''perceived'' to perform a single operation or represent a single data item, but at a more abstract level than those provided by the machine. Copying a data item from one location to another may actually involve many [[machine instruction]]s that, for instance, 
* calculate the address of both [[operand]]s in [[computer memory|memory]], based on their positions within a [[data structure]], 
* convert from one [[data type]] to another
before finally
* performing the final store operation to the target destination. 

Some [[HLL]] statements, particularly those involving [[Control flow#Loops|loops]], can generate thousands or even millions of primitives in a [[Low-level programming language|low level language]] - which comprise the genuine [[instruction path length]] the processor has to execute at the lowest level. This perception has been referred to as the "Abstraction penalty" <ref>{{cite paper
  | author = Surana P
  | title = Meta-Compilation of Language Abstractions.
  | year = 2006
  | url = ftp://lispnyc.org/meeting-assets/2007-02-13_pinku/SuranaThesis.pdf
  | format = [[PDF]]
  | accessdate = 2008-03-17 }}</ref><ref>{{cite web
  | last = Kuketayev 
  | title = The Data Abstraction Penalty (DAP) Benchmark for Small Objects in Java.
  | url= http://www.adtmag.com/joop/article.aspx?id=4597
  | accessdate = 2008-03-17 }}</ref><ref>{{Cite book
  | last = Chatzigeorgiou
  | last2 = Stephanides 
  | editor-last = Blieberger 
  | editor2-last = Strohmeier 
  | contribution = Evaluating Performance and Power Of Object-Oriented Vs. Procedural Programming Languages
  | title = Proceedings - 7th International Conference on Reliable Software Technologies - Ada-Europe'2002
  | year = 2002
  | pages = 367
  | publisher = Springer
  | url = http://books.google.com/?id=QMalP1P2kAMC&dq=%22abstraction+penalty%22
  | isbn = 9783540437840
 }}</ref>

==Interpreted language primitives==
An interpreted language statement has similarities to the [[HLL]] primitives but with a further added 'layer'. Before the statement can be executed in a manner very similar to a [[HLL]] statement, first, it has to be  processed by an [[interpreter]], a process that may involve many primitives in the target machine language.

==Fourth and Fifth-generation programming language primitives==
[[Fourth-generation programming language|4gl]]s and [[Fifth-generation programming language|5gl]]s do not have a simple one-to-many correspondence from high-to-low level primitives. There are some elements of interpreted language primitives embodied in [[4GL|4gl]] and [[Fifth-generation programming language|5gl]] specifications but the approach to the original problem is less a [[procedural language]] construct and are more oriented toward [[problem solving]] and [[systems engineering]].

==See also==
* [[Primitive type]]
* [[Hardware-software codesign]]

==References==
<references />

[[Category:Programming language topics]]
[[Category:Computer languages]]


{{prog-lang-stub}}</body> </html>