<html> <head> <title>Software framework</title></head><body>In [[computer programming]], a '''software framework''' is an abstraction in which common code providing generic functionality can be selectively overridden or specialized by user code, thus providing specific functionality. Frameworks are a special case of [[software library|software libraries]] in that they are reusable abstractions of code wrapped in a well-defined [[application programming interface|Application programming interface (API)]], yet they contain some key distinguishing features that separate them from normal libraries.  

Software frameworks have these distinguishing features that separate them from libraries or normal user applications:
# '''[[inversion of control]]''' - In a framework, unlike in libraries or normal user applications, the overall program's [[control flow|flow of control]] is not dictated by the caller, but by the framework.<ref>{{citation|url=http://www.riehle.org/computer-science/research/dissertation/diss-a4.pdf|first=Dirk|last=Riehle|title=Framework Design: A Role Modeling Approach|publisher=[[ETH Zurich|Swiss Federal Institute of Technology]]|year=2000|postscript=<!--none-->}}</ref>
# '''default behavior''' - A framework has a default behavior. This default behavior must actually be some useful behavior and not a series of [[NOP|no-ops]].
# '''[[extensibility]]''' - A framework can be extended by the user usually by selective overriding or specialized by user code providing specific functionality.
# '''non-modifiable framework code''' - The framework code, in general, is not allowed to be modified. Users can extend the framework, but not modify its code.

There are different types of software frameworks: conceptual, application, domain, platform, component, service, development, etc.<ref>{{cite web|first = Tony|last = Shan|date = 2006|accessdate = 2010-10-10|url = http://portal.acm.org/citation.cfm?id=1190953|title = Taxonomy of Java Web Application Frameworks|publisher = Proceedings of 2006 IEEE International Conference on e-Business Engineering (ICEBE 2006)}}</ref>

== Rationale ==
The designers of software frameworks aim to facilitate software development by allowing designers and programmers to devote their time to meeting software requirements rather than  dealing with the more standard low-level details of providing a working system, thereby reducing overall development time.<ref>{{cite web |url=http://docforge.com/wiki/Framework |title=Framework |accessdate=15 December 2008 |work= DocForge}}</ref>  For example, a team using a [[web application framework]] to develop a banking web-site can focus on the operations of account withdrawals rather than the mechanics of request handling and state management.

By way of contrast, an in-house or purpose-built framework might be specified for the same project by a programming team as they begin working the overall job{{mdash}}specifying software needs based on first defining data types, structures and processing has long been taught as a successful strategy for top down design. Contrasting software data, its manipulation, and how a software system's various grades and kinds of users will need to either input, treat, or output the data are then used to specify the user interface(s) {{mdash}}some types of access being privileged and locked to other user types{{mdash}} all defining the overall user interfaces which to the users are the visible in-house Framework for the custom coded project. In such a case, each sort of operation, user interface code and so forth need written and separately integrated into the job at hand also more or less adding to necessary testing and validation.

It can be argued that frameworks add to "[[code bloat]]", and that due to customer-demand driven applications needs both competing and complementary frameworks sometimes end up in a product.  Further, some cognoscenti argue, because of the complexity of their APIs, the intended reduction in overall development time may not be achieved due to the need to spend additional time learning to use the framework{{mdash}}which criticism is certainly valid when a special or new framework is first encountered by a development staff. If such a framework is not utilized in subsequent job taskings, the time invested ascending the framework's learning curve might be more expensive than purpose written code familiar to the project's staff{{mdash}}many programmers keep aside useful boilerplate for common needs. 

{{bull}}However, it could be argued that once the framework is learned, future projects might be quicker and easier to complete{{mdash}}the concept of a framework is to make a one-size-fits-all solution set, and with familiarity, code production should logically be increased. There are no such claims made about the size of the code eventually bundled with the output product, nor its relative efficiency and conciseness. Using any library solution necessarily pulls in extras and unused extraneous assets unless the software is a compiler-object linker making a tight (small, wholly controlled, and specified) executable module.

{{bull}}The issue continues, but a decade-plus of industry experience has shown that the most effective frameworks turn out to be those that evolve from re-factoring the common code of the enterprise, as opposed to using a generic "one-size-fits-all" framework developed by third-parties for general purposes. An example of that would be how the user interface in such an application package as an Office suite grows to have common look, see, feel and data sharing attributes and methods as the once disparate bundled applications become unified{{mdash}}hopefully a suite which is tighter and smaller as the newer evolved one can be a product sharing integral utility libraries and user interfaces.

This trend in the controversy brings up an important issue about frameworks. Creating a framework that is elegant, as opposed to one that merely solves a problem, is still an art rather than a science. "[[elegance|Software elegance]]" implies clarity, conciseness, and little waste (extra or extraneous functionality{{mdash}}much of which is user defined). For those frameworks that generate code, for example, "elegance" would imply the creation of code that is clean and comprehensible to a reasonably knowledgeable programmer (and which is therefore readily modifiable), as opposed to one that merely generates correct code. The elegance issue is why relatively few software frameworks have stood the test of time: the best frameworks have been able to evolve gracefully as the underlying technology on which they were built advanced. Even there, having evolved, many such packages will retain legacy capabilities bloating the final software as otherwise replaced methods have been retained in parallel with the newer methods.

== Examples ==

Software frameworks typically contain considerable housekeeping and utility code in order to help bootstrap user applications, but generally focus on specific problem domains, such as:
* Artistic drawing, music composition, and mechanical [[CAD]]<ref>{{citation|doi = 10.1145/98188.98197|last1 = Vlissides|first1 = J M|last2 = Linton|first2 = M A|year = 1990|title = Unidraw: a framework for building domain-specific graphical editors|journal = ACM Transactions of Information Systems|volume = 8|issue = 3|pages =237–268|postscript = <!--none-->}}</ref><ref>{{citation|last = Johnson|first = R E|year = 1992|title = Documenting frameworks using patterns|publisher = ACM Press|journal = Proceedings of the Conference on Object Oriented Programming Systems Languages and Applications|pages = 63–76|postscript = <!--none-->}}</ref>
* [[Compiler]]s for different [[programming language]]s and target machines.<ref>{{citation|last1 = Johnson|first1 = R E|first2 = C|last2 = McConnell|first3 = M J|last3 = Lake|year = 1992|title = The RTL system: a framework for code optimization|editor-first = R|editor-last = Giegerich|editor2-first = S L|editor2-last = Graham|publisher = [[Springer-Verlag]]|journal = Proceedings of the International workshop on code generation|pages = 255–274|postscript = <!--none-->}}</ref>
* Financial modeling applications<ref>{{citation|last1 = Birrer|first1 = A|first2 = T|last2 = Eggenschwiler|year = 1993|title = Frameworks in the financial engineering domain: an experience report|publisher = [[Springer-Verlag]]|DUPLICATE DATA: title = Proceedings of the European conference on object-oriented programming|pages = 21–35|postscript = <!--none-->}}</ref>
* Earth system modeling applications<ref>{{citation|last1 = Hill|first1 = C|first2 = C|last2 = DeLuca|first3 = V|last3 = Balaji|first4 = M|last4 = Suarez|first5 = A|last5 = da Silva|title = Architecture of the Earth System Modeling Framework ([[ESMF]])|journal = Computing in Science and Engineering|year = 2004|pages = 18–28|postscript = <!--none-->}}</ref>
* [[Decision support systems]]<ref>{{citation|last = Gachet|first = A|year = 2003|title = Software Frameworks for Developing Decision Support Systems - A New Component in the Classification of DSS Development Tools|journal = Journal of Decision Systems|volume = 12|issue = 3|pages = 271–281|postscript = <!--none-->}}</ref>
* [[Multimedia framework|Media playback and authoring]]
* [[Web application framework|Web applications]]
* [[Middleware]]

== Architecture ==

According to Pree,<ref>{{citation|title = Meta Patterns-A Means For Capturing the Essentials of Reusable Object-Oriented Design|author = Pree, W|journal = Proceedings of the 8th European Conference on Object-Oriented Programming|pages = 150–162|year = 1994|publisher = [[Springer-Verlag]]|postscript = <!--none-->}}</ref> software frameworks consist of ''frozen spots'' and ''hot spots''. ''Frozen spots'' define the overall architecture of a software system, that is to say its basic components and the relationships between them. These remain unchanged (frozen) in any instantiation of the application framework. ''Hot spots'' represent those parts where the programmers using the framework add their own code to add the functionality specific to their own project.

Software frameworks define the places in the [[software architecture|architecture]] where application programmers may make adaptations for specific functionality—the hot spots.

In an [[Object-oriented programming|object-oriented]] environment, a framework consists of [[Abstract class|abstract]] and [[Class_(computer_science)#Concrete_classes|concrete]] [[Class (computer science)|classes]]. [[Instantiation]] of such a framework consists of [[Object composition|composing]] and [[subclass (computer science)|subclassing]] the existing classes.<ref>{{citation|last = Buschmann|first = F|year = 1996|title = Pattern-Oriented Software Architecture Volume 1: A System of Patterns. Chichester|publisher = [[John Wiley & Sons|Wiley]]|isbn = 0471958697|postscript = <!--none-->}}</ref>

When developing a concrete software system with a software framework, developers utilize the hot spots according to the specific needs and requirements of the system. Software frameworks rely on the [[Hollywood Principle]]: "Don't call us, we'll call you."<ref>{{citation|last = Larman|first = C|year = 2001|title = Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design and the Unified Process|isbn = 0130925691|publisher = [[Prentice Hall]]|edition = 2nd|postscript = <!--none-->}}</ref> This means that the user-defined classes (for example, new subclasses), receive messages from the predefined framework classes. Developers usually handle this by implementing [[superclass (computer science)|superclass]] [[abstract method]]s.

== See also ==

* [[Application framework]]
* [[Class (computer science)]]
* [[Design pattern (computer science)]]
* [[Don't repeat yourself]]
* [[Enterprise Architecture framework]]
* [[Implicit invocation]]
* [[Programming paradigm]]
* [[Web application framework]]

== References ==

{{reflist}}

[[Category:Integrated development environments]]
[[Category:Software architecture]]
[[Category:Object-oriented programming]]

[[ar:إطار عمل (برمجة)]]
[[bn:ফ্রেমওয়ার্ক]]
[[ca:Framework]]
[[cs:Framework]]
[[da:Framework]]
[[de:Framework]]
[[es:Framework]]
[[fa:چارچوب نرم‌افزار]]
[[fr:Framework]]
[[ko:소프트웨어 프레임워크]]
[[id:Kerangka kerja]]
[[it:Framework]]
[[he:שלד תוכנה]]
[[nl:Framework]]
[[ja:ソフトウェアフレームワーク]]
[[pl:Framework]]
[[pt:Framework]]
[[ru:Фреймворк]]
[[simple:Framework]]
[[fi:Ohjelmistokehys]]
[[ta:மென்பொருள் சட்டகம்]]
[[th:ซอฟต์แวร์เฟรมเวิร์ก]]
[[uk:Фреймворк]]
[[zh:軟體框架]]</body> </html>