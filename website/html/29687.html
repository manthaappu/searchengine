<html> <head> <title>Post correspondence problem</title></head><body>The '''Post correspondence problem''' is an [[undecidable problem|undecidable]] [[decision problem]] that was introduced by [[Emil Post]] in 1946.<ref name="Post46">{{cite journal|year = 1946|author = [[Emil Post|E. L. Post]]| title= [http://www.ams.org/bull/1946-52-04/S0002-9904-1946-08555-9/S0002-9904-1946-08555-9.pdf A variant of a recursively unsolvable problem] |journal = Bull. Amer. Math. Soc| volume =  52}}</ref> Because it is simpler than the [[halting problem]] and the ''[[Entscheidungsproblem]]'' it is often used in proofs of undecidability.

== Definition of the problem ==

The input of the problem consists of two finite lists <math>\alpha_{1}, \ldots, \alpha_{N}</math> and <math>\beta_{1}, \ldots, \beta_{N}</math> of words over some alphabet <math>A</math> having at least two symbols. A solution to this problem is a [[sequence]] of indices <math>(i_k)_{1 \le k \le K}</math> with <math>K \ge 1</math> and <math> 1 \le i_k \le N</math> for all <math>k</math>, such that

: <math>\alpha_{i_1} \ldots \alpha_{i_K} = \beta_{i_1} \ldots \beta_{i_K}.</math>

The decision problem then is to decide whether such a solution exists or not.

== Example instances of the problem ==
===Example 1===
Consider the following two lists:
<table border="0" cellspacing="2" cellpadding="2">
<tr><td>
{| class="wikitable" style="text-align:center;background:#05FFD3;" 
|width=40 | <math>\alpha_1</math>
|width=40 | <math>\alpha_2</math>
|width=40 | <math>\alpha_3</math>
|-
|<math>a</math>
|<math>ab</math>
|<math>bba</math>
|}
</td>
<td valign="middle"> </td>
<td>
{| class="wikitable" style="text-align:center;background:#57D6FF;" 
|width=40 | <math>\beta_{1}</math>
|width=40 | <math>\beta_{2}</math>
|width=40 | <math>\beta_{3}</math>
|-
|<math>baa</math>
|<math>aa</math>
|<math>bb</math>
|}
</td></tr></table>
A solution to this problem would be the sequence (3, 2, 3, 1), because

: <math>\alpha_3 \alpha_2 \alpha_3 \alpha_1 = bba + ab + bba + a = bbaabbbaa = bb + aa + bb + baa = \beta_{3} \beta_{2} \beta_{3} \beta_{1}.</math>

Furthermore, since (3, 2, 3, 1) is a solution, so are all of its "repetitions", such as (3, 2, 3, 1, 3, 2, 3, 1), etc.; that is, when a solution exists, there are infinitely many solutions of this repetitive kind.

However, if the two lists had consisted of only <math>\alpha_2, \alpha_3</math> and <math>\beta_{2}, \beta_{3}</math>, then there would have been no solution (because then no matching pair would have the same last letter, as must occur at the end of a solution).

A convenient way to view an instance of a Post correspondence problem is as a collection of blocks of the form
<table border="0" cellspacing="2" cellpadding="2">  
<tr><td>
{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | <math>\alpha_{i}</math>
|-
| bgcolor="#57D6FF" width="40" | <math>\beta_{i}</math>
|}
</td></tr>
</table>
there being an unlimited supply of each type of block. Thus the above example is viewed as
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td>
<div align="center"> </div>
<table border="0" cellspacing="0" cellpadding="2">
<tr align="center">
<td>
{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | <math>a</math>
|-
| bgcolor="#57D6FF" width="40" | <math>baa</math>
|}
</td>
<td valign="center">,</td>
<td>
{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | <math>ab</math>
|-
| bgcolor="#57D6FF" width="40" | <math>aa</math>
|}
</td>
<td valign="center">,</td>
<td>
{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | <math>bba</math>
|-
| bgcolor="#57D6FF" width="40" | <math>bb</math>
|}
</td>
</tr>
<tr>
<td align="center"><math>i=1</math>
</td>
<td align="center">
</td>
<td align="center"><math>i=2</math>
</td>
<td align="center">
</td>
<td align="center"><math>i=3</math>
</td>
<td align="center">
</td>
</tr>
</table>
</table>
where the solver has an endless supply of each of these three block types. A solution corresponds to some way of laying blocks next to each other so that the string in the top cells corresponds to the string in the bottom cells. Then the solution to the above example corresponds to:
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td>
<div align="center"> </div>
<table border="0" cellspacing="0" cellpadding="0">
<tr align="center">
<td>
{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | <math>bba</math>
|-
| bgcolor="#57D6FF" width="40" | <math>bb</math>
|}
</td>
<td>
{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | <math>ab</math>
|-
| bgcolor="#57D6FF" width="40" | <math>aa</math>
|}
</td>
<td>
{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | <math>bba</math>
|-
| bgcolor="#57D6FF" width="40" | <math>bb</math>
|}
</td>
<td>
{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | <math>a</math>
|-
| bgcolor="#57D6FF" width="40" | <math>baa</math>
|}
</td>
</tr>
<tr>
<td align="center"><math>i_1=3</math> 
</td>
</td>
<td align="center"><math>i_2=2</math> 
</td>
</td>
<td align="center"><math>i_3=3</math> 
</td>
</td>
<td align="center"><math>i_4=1</math> 
</td>
</tr>
</table>
</table>

===Example 2===
Again using blocks to represent an instance of the problem, the following is an example that has infinitely many solutions in addition to the kind obtained by merely "repeating" a solution. For readability, just the block number is shown below each block:

<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td>
<div align="center"> </div>
<table border="0" cellspacing="0" cellpadding="2">
<tr align="center">
<td>
{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | <math>bb</math>
|-
| bgcolor="#57D6FF" width="40" | <math>b</math>
|}
</td>
<td valign="center">,</td>
<td>
{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | <math>ab</math>
|-
| bgcolor="#57D6FF" width="40" | <math>ba</math>
|}
</td>
<td valign="center">,</td>
<td>
{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | <math>c</math>
|-
| bgcolor="#57D6FF" width="40" | <math>bc</math>
|}
</td>
</tr>
<tr valign="top">
<td align="center">1
</td>
<td align="center">
</td>
<td align="center">2
</td>
<td align="center">
</td>
<td align="center">3
</td>
<td align="center">
</td>
</tr>
</table>
</table>

In this instance, every sequence of the form (1, 2, 2, ..., 2, 3) is a solution (in addition to all their repetitions):

<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td>
<div align="center"> </div>
<table border="0" cellspacing="0" cellpadding="0">
<tr align="center">
<td>
{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | <math>bb</math>
|-
| bgcolor="#57D6FF" width="40" | <math>b</math>
|}
</td>
<td>
{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | <math>ab</math>
|-
| bgcolor="#57D6FF" width="40" | <math>ba</math>
|}
</td>
<td>
{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | <math>ab</math>
|-
| bgcolor="#57D6FF" width="40" | <math>ba</math>
|}
</td>
<td valign="center">...</td>
<td>
{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | <math>ab</math>
|-
| bgcolor="#57D6FF" width="40" | <math>ba</math>
|}
</td>
<td>
{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | <math>c</math>
|-
| bgcolor="#57D6FF" width="40" | <math>bc</math>
|}
</td>
</tr>
<tr valign="top">
<td align="center">1
</td>
</td>
<td align="center">2 
</td>
</td>
<td align="center">2 
</td>
<td></td>
</td>
<td align="center">2 
</td>
<td align="center">3 
</td>
</tr>
</table>
</table>

== Proof sketch of undecidability ==

The most common proof for the undecidability of PCP describes an instance of PCP that can simulate the computation of a [[Turing machine]] on a particular input. A match will only occur if the input would be accepted by the Turing machine. Because deciding if a Turing machine will accept an input is a basic undecidable problem, PCP cannot be decidable either. The following discussion is based on [[Michael Sipser]]'s textbook ''Introduction to the Theory of Computation''.<ref name="sipser05">{{cite book|author = [[Michael Sipser]] | year = 2005 | title = Introduction to the Theory of Computation | edition = 2nd | publisher = Thomson Course Technology | isbn = 0-534-95097-3 | chapter = A Simple Undecidable Problem | pages = 199&ndash;205}}</ref>

In more detail, the idea is that the string along the top and bottom will be a [[computation history]] of the Turing machine's computation. This means it will list a string describing the initial state, followed by a string describing the next state, and so on until it ends with a string describing an accepting state. The state strings are separated by some separator symbol (usually written #). According to the definition of a Turing machine, the full state of the machine consists of three parts:
* The current contents of the tape.
* The current state of the [[finite state machine]] which operates the tape head.
* The current position of the tape head on the tape.
Although the tape has infinitely many cells, only some finite prefix of these will be non-blank. We write these down as part of our state. To describe the state of the finite control, we create new symbols, labelled ''q''<sub>1</sub> through ''q''<sub>''k''</sub>, for each of the finite state machine's ''k'' states. We insert the correct symbol into the string describing the tape's contents at the position of the tape head, thereby indicating both the tape head's position and the current state of the finite control. For the alphabet {0,1}, a typical state might look something like:

101101110''q''<sub>7</sub>00110.

A simple computation history would then look something like this:

''q''<sub>0</sub>101#1''q''<sub>4</sub>01#11''q''<sub>2</sub>1#1''q''<sub>8</sub>10.

We start out with this block, where ''x'' is the input string and ''q''<sub>0</sub> is the start state:

{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" |  
|-
| bgcolor="#57D6FF" width="40" | ''q''<sub>0</sub>''x''#
|}

The top starts out "lagging" the bottom by one state, and keeps this lag  until the very end stage. Next, for each symbol ''a'' in the tape alphabet, as well as #, we have a "copy" block, which copies it unmodified from one state to the next:

{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | ''a''
|-
| bgcolor="#57D6FF" width="40" | ''a''
|}

We also have a block for each position transition the machine can make, showing how the tape head moves, how the finite state changes, and what happens to the surrounding symbols. For example, here the tape head is over a 0 in state 4, and then writes a 1 and moves right, changing to state 7:

{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | ''q''<sub>4</sub>0
|-
| bgcolor="#57D6FF" width="40" | 1''q''<sub>7</sub>
|}

Finally, when the top reaches an accepting state, the bottom needs a chance to finally catch up to complete the match. To allow this, we extend the computation so that once an accepting state is reached, each subsequent machine step will cause a symbol near the tape head to vanish, one at a time, until none remain. If ''q''<sub>''f''</sub> is an accepting state, we can represent this with the following transition blocks, where ''a'' is a tape alphabet symbol:

<table border="0" cellspacing="0" cellpadding="0">
<tr align="center">
<td>
{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | ''q''<sub>''f''</sub>''a''
|-
| bgcolor="#57D6FF" width="40" | ''q''<sub>''f''</sub>
|}
</td>
<td valign="center">,</td>
<td>
{| class="wikitable" style="text-align:center;"
| bgcolor="#05FFD3" width="40" | ''aq''<sub>''f''</sub>
|-
| bgcolor="#57D6FF" width="40" | ''q''<sub>''f''</sub>
|}
</td>
</tr></table>

There are a number of details to work out, such as dealing with boundaries between states, making sure that our initial tile goes first in the match, and so on, but this shows the general idea of how a static tile puzzle can simulate a Turing machine computation.

== Variants ==

Many variants of PCP have been considered. One reason is that, when one tries to prove undecidability of some new problem by reducing from PCP, it often happens that the first reduction one finds is not from PCP itself but from an apparently weaker version.

* The condition that the alphabet <math>A</math> have at least two symbols is required since the problem is decidable if <math>A</math> has only one symbol.

* A simple variant is to fix ''n'', the number of tiles. This problem is decidable if ''n'' ≤ 2, but remains undecidable for ''n'' ≥ 7. It is unknown whether the problem is decidable for 3 ≤ ''n'' ≤ 6.

* The '''''circular'' Post correspondence problem''' asks whether indexes <math>i_1, i_2, ...</math> can be found such that <math>\alpha_{i_1} \cdots \alpha_{i_k}</math> and <math>\beta_{i_1} \cdots \beta_{i_k}</math> are [[conjugacy|conjugate words]], i.e., they are equal modulo rotation. This variant is undecidable.<ref name="Ruohonen83">{{cite journal|author= K. Ruohonen |year =1983|title=On some variants of Post's correspondence problem|publisher=Springer|volume=19|issue=4|pages=357&ndash;367|journal=Acta Informatica | doi = 10.1007/BF00290732}}</ref>

* One of the most important variants of PCP is the '''''bounded'' Post correspondence problem''', which asks if we can find a match using no more than ''k'' tiles, including repeated tiles. A brute force search solves the problem in time O(2<sup>''k''</sup>), but this may be difficult to improve upon, since the problem is [[NP-complete]].<ref name="GJ79">{{cite book|author = [[Michael R. Garey]]|coauthors=[[David S. Johnson]] | year = 1979 | title = [[Computers and Intractability: A Guide to the Theory of NP-Completeness]] | publisher = W.H. Freeman | isbn = 0-7167-1045-5 | page = 228 }}</ref> Unlike some NP-complete problems like the [[boolean satisfiability problem]], a small variation of the bounded problem was also shown to be complete for RNP, which means that it remains hard even if the inputs are chosen at random (it is hard on average over uniformly distributed inputs).<ref name="Gurevich91">{{cite journal|author = Y. Gurevich|journal = J. Comp. Sys. Sci.|year = 1991|pages = 346–398|volume=42|title= Average case completeness|publisher=Elsevier Science|doi = 10.1016/0022-0000(91)90007-R|issue=3}}</ref>

* Another variant of PCP is called the '''''marked'' Post Correspondence Problem''', in which each ''u''<sub>''i''</sub> must begin with a different symbol, and each ''v''<sub>''i''</sub> must also begin with a different symbol. Halava, Hirvensalo, and de Wolf showed that this variation is decidable in [[EXPTIME|exponential time]]. Moreover, they showed that if this requirement is slightly loosened so that only the two-character prefixes need to differ (the so-called 2-marked Post Correspondence Problem), the problem becomes undecidable again.<ref name="HHW01">{{cite journal|author = V. Halava|coauthors= M. Hirvensalo and R. de Wolf|year=2001|title=Marked PCP is decidable|journal=Theor. Comp. Sci.|publisher=Elsevier Science|volume=255|pages=193–204|doi=10.1016/S0304-3975(99)00163-2}}</ref>

* The '''Post Embedding Problem''' is another variant where one looks for indexes <math>i_1, i_2, ...</math> such that <math>\alpha_{i_1} \cdots \alpha_{i_k}</math> is a [[substring|(scattered) subword]] of <math>\beta_{i_1} \cdots \beta_{i_k}</math>. This variant is easily decidable since, when some solutions exist, in particular  a length-one solution exists. More interesting is the '''Regular''' Post Embedding Problem, a further variant where one looks for solutions  that belong to a given regular language (submitted, e.g., under the form of a regular expression on the set <math>\{1,...,N\}</math>). The Regular Post Embedding Problem is still decidable but,  because of the added regular constraint, it has a very high complexity that dominates every multiply-recursive function.<ref name="CS07">{{cite journal|author = P. Chambart|coauthors = Ph. Schnoebelen|title = Post embedding problem is not primitive recursive, with applications to channel systems|year = 2007|journal = Lecture Notes in Computer Science|volume =4855|pages=265–276|publisher=Springer|doi=10.1007/978-3-540-77050-3_22}}</ref>

== References ==
<references/>

== External links ==

* Eitan M. Gurari. ''An Introduction to the Theory of Computation'', Chapter 4, [http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-fourse7.html Post's Correspondence Problem]. A proof of the undecidability of PCP based on a generalization of [[context-free grammar]]s.
* [http://jamesvanboxtel.com/projects/pcp-solver/ Online PHP Based PCP Solver]
* [http://www.theory.informatik.uni-kassel.de/~stamer/pcp/pcpcontest_en.html PCP AT HOME]

{{DEFAULTSORT:Post Correspondence Problem}}
[[Category:Theory of computation]]
[[Category:Recursion theory]]

[[cs:Postův korespondenční problém]]
[[de:Postsches Korrespondenzproblem]]
[[es:Problema de correspondencia de Post]]
[[he:בעיית ההתאמה של פוסט]]
[[pl:Problem odpowiedniości Posta]]
[[tr:Post Correspondence Problemi]]</body> </html>