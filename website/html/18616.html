<html> <head> <title>Integer circuit</title></head><body>'''[[Integer]] [[Circuit (computer theory)|circuit]]s ''' is a mathematical model used in studying [[computational complexity theory]]. It is a special case of [[circuit (computer theory)|circuit]], the object is a labeled [[directed acyclic graph]] the nodes of which evaluate to sets of integers, the leaves are finite sets, and the gates are set operations or arithmetic operations. 

As an [[algorithm]]ic problem, the possible question are to find if a given integer is an element is in the output node or if two circuits compute the same set. The decidability is still an open question, but there are results on restriction of thoses circuits. Finding answers to some questions about this model could serve as a proof to many important mathematical conjectures, like [[Goldbach's conjecture]]. 

It is a natural extension of the [[circuits over sets of natural numbers]] when the considered set contains also negative integers, the definitions, which does not change, will not be repeated on this page. Only the differences will be mentioned.

== Complexity results ==
=== Membership problem ===
The membership problem ask if, given an element <math>n</math> and a circuit, if <math>n</math> is in the output gate of the circuit.

When the class of authorized gate is restricted, the membership problem lay inside well kwown complexity classes<ref>{{Citation
 | author = Stephen Travers
 | title = The complexity of membership problems for circuits over sets of integers
 | journal =Theoretical Computer Science
 | volume =369
 | edition= (what is called "number" in bibtex)
 | issue = 1
 | year =2006
 | issn =0304-3975
 | pages =211&ndash;229  
 | publisher =Elsevier Science Publishers Ltd
 | place = Essex, UK
 | url = http://portal.acm.org/citation.cfm?id=1238761
}}</ref>.

{| class="wikitable" style="text-align:center; width:80%;"
|+ Complexity
|-
! scope=col | O
! scope=col | MC<math>_{\mathbb Z}</math>(O) 
! scope=col | MF<math>_{\mathbb Z}</math>(O)
|-
! scope=row | ∪,∩,&minus;,+,×
| [[NEXPTIME]]-hard
| [[PSPACE]]-hard
|-
! scope=row | ∪,∩,+,×
| [[NEXPTIME]]-complete
| [[NP-complete]]
|-
! scope=row | ∪,+,×
| [[NEXPTIME]]-complete
| [[NP-complete]]
|-
! scope=row | ∩,+,×
| [[P (complexity)|P]]-hard, in [[co-NP]]
| [[L (complexity)|L]]-hard, in [[LOGCFL]]
|-
! scope=row | +,×
| [[P (complexity)|P]]-hard, in [[co-NP]]
| [[L (complexity)|L]]-hard, in [[LOGCFL]]
|-
! scope=row | ∪,∩,&minus;,+
| [[PSPACE]]-complete
| [[PSPACE]]-complete
|-
! scope=row | ∪,∩,+
| [[PSPACE]]-complete
| [[NP-complete]]
|-
! scope=row | ∪,+
| [[NP-complete]]
| [[NP-complete]]
|-
! scope=row | ∩,+
| [[CL (complexity)|C<sub>=</sub>L]]-complete
| [[L (complexity)|L]]-complete
|-
! scope=row | +
| [[CL (complexity)|C<sub>=</sub>L]]-complete
| [[L (complexity)|L]]-complete
|-
! scope=row | ∪,∩,&minus;,×
| [[PSPACE]]-complete
| [[PSPACE]]-complete
|-
! scope=row | ∪,∩,×
| [[PSPACE]]-complete
| [[NP-complete]]
|-
! scope=row | ∪,×
| [[NP-complete]]
| [[NP-complete]]
|-
! scope=row | ∩,×
| ([[CL (complexity)|C<sub>=</sub>L]]<math>\land\oplus</math>L)-hard, in [[P (complexity)|P]]
| [[L (complexity)|L]]-complete
|-
! scope=row | ×
| ([[NL (complexity)|NL]]-complete<math>\land\oplus</math>L)-complete
| [[L (complexity)|L]]-complete
|-
! scope=row | ∪,∩,&minus;
| [[P (complexity)|P]]-complete
| [[L (complexity)|L]]-complete
|-
! scope=row | ∪,∩
| [[P (complexity)|P]]-complete
| [[L (complexity)|L]]-complete
|-
! scope=row | ∪
| [[NL (complexity)|NL]]-complete
| [[L (complexity)|L]]-complete
|-
! scope=row | ∩
| [[NL (complexity)|NL]]-complete
| [[L (complexity)|L]]-complete
|}
== References ==
{{Reflist}}

[[Category:Computational complexity theory]]
[[Category:Arithmetic]]</body> </html>